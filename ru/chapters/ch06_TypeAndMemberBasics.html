<!doctype html>
<html lang="ru-RU">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <link rel="icon" href="/assets/img/favicon.ico"><title>Основные сведения о членах и типах | CLR via C#</title><meta name="description" content="CLR via C# Четвертое издание">
    <link rel="preload" href="/clr-via-csharp/assets/style-FaCSB-_p.css" as="style"><link rel="stylesheet" href="/clr-via-csharp/assets/style-FaCSB-_p.css">
    <link rel="modulepreload" href="/clr-via-csharp/assets/app-IxoMmWNN.js"><link rel="modulepreload" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-BGwRCWdf.js">
    <link rel="prefetch" href="/clr-via-csharp/assets/index.html-ZkH5qKEm.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-BvaI8qfN.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-D-7172Jl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BLQSYEbL.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-Cmb5tXx5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-C65m3L6w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-MhrBc603.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BExRN6IU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-Cwf82xZd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-U9jK40Ei.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CUDFuVYa.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-0oTJyJmn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-LLUaep7w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-Bi9j89Ya.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-Dbx7WK6o.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-DsmoFQbF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-noMBAT3f.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-MFb5H9zK.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-ZDLMr6H2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DYgFyOwD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-BtysPki2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CDUugoVg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BWeh_aT3.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-CfeNN69i.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-D16BElAb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-DK1leolo.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-CQ2ygEuE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-C3cvw10V.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-CMPdATok.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-CTieDbCf.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CJcp4OCy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-CFsstSQQ.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-beZI77Lv.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-Bi67Yt5h.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-dvExR8Gk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-GDcN_xMH.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BwKxRLwh.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-BMQPeoI2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-27zHcXlW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-CVDf2x4Y.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-DkaxxntM.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-D2jgyLeB.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CcZqtO9s.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-Cgf_mCwx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-CO8XAMmW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-DZ5a5JQg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-D0mGmkov.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-BGdd7LBY.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-DExRFCv1.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BiTZ-5od.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-Dsjpqw47.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DWEP33D9.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-DtaR-VvP.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CvrkASkk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BuN-nGuz.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-f0AOnmUF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-C4pcwqj-.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-CHZCU__5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-emd0r8wc.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-BmMk3Oqy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-DDuBq2h_.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DXXfHTUn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CwFR1TuA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-Bjaf8DNA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-D2MW45gx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-Bpkc--tR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BPnkWvJ8.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-q0yDwRpt.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-BjqQ7sdC.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-BIIy8leD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BOo-9fso.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-DzDrvZ87.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-CASmG777.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CEM163Qb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-BkR6SOXn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-sfPfXudR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-LJfkVvEp.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-CSXiWNpq.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-CBasocgy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-o4yS52Dy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BZtqvWYE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-CGp-_Jrw.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-tcKP_pXy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-B6RvN9hy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-BkMiV6yx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BsTwrSmr.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-BDn6rSrD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-Bi_35IQj.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-stJPEo8t.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-BexV0ImS.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-Cw_fsfmx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-QnhhtSZl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DNJcQUkI.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-BAwtWkjU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-5-bQNQmT.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-DKmbpj4c.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-GASyXvmd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-D6bO62ut.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/404.html-5gOqppNC.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/clr-via-csharp/ru/"><img class="logo" src="/clr-via-csharp/assets/images/cover.jpg" alt="CLR via C#"><span class="site-name can-hide" aria-hidden="true">CLR via C#</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/chapters/ch06_TypeAndMemberBasics.html" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/chapters/ch06_TypeAndMemberBasics.html" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch01_TheCLRSExecutionMode.html" aria-label="Модель выполнения кода в среде CLR"><!--[--><!--[--><!--]--> Модель выполнения кода в среде CLR <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch02_Building.html" aria-label="Компоновка, упаковка, развёртывание и администрирование приложений и типов"><!--[--><!--[--><!--]--> Компоновка, упаковка, развёртывание и администрирование приложений и типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch03_SharedAssemblies.html" aria-label="Совместно используемые сборки и сборки со строгим именем"><!--[--><!--[--><!--]--> Совместно используемые сборки и сборки со строгим именем <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch04_TypeFundamentals.html" aria-label="Основы типов"><!--[--><!--[--><!--]--> Основы типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch05_PrimitiveRefValType.html" aria-label="Примитивные, ссылочные и значимые типы"><!--[--><!--[--><!--]--> Примитивные, ссылочные и значимые типы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active sidebar-item sidebar-heading active" href="/clr-via-csharp/ru/chapters/ch06_TypeAndMemberBasics.html" aria-label="Основные сведения о членах и типах"><!--[--><!--[--><!--]--> Основные сведения о членах и типах <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#члены-типа" aria-label="Члены типа"><!--[--><!--[--><!--]--> Члены типа <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#видимость-типа" aria-label="Видимость типа"><!--[--><!--[--><!--]--> Видимость типа <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#дружественные-сборки" aria-label="Дружественные сборки"><!--[--><!--[--><!--]--> Дружественные сборки <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#доступ-к-членам-типов" aria-label="Доступ к членам типов"><!--[--><!--[--><!--]--> Доступ к членам типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#статические-классы" aria-label="Статические классы"><!--[--><!--[--><!--]--> Статические классы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#частичные-классы-структуры-и-интерфеисы" aria-label="Частичные классы, структуры и интерфейсы"><!--[--><!--[--><!--]--> Частичные классы, структуры и интерфейсы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#компоненты-полиморфизм-и-версии" aria-label="Компоненты, полиморфизм и версии"><!--[--><!--[--><!--]--> Компоненты, полиморфизм и версии <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#вызов-виртуальных-методов-своиств-и-событии-в-clr" aria-label="Вызов виртуальных методов, свойств и событий в CLR"><!--[--><!--[--><!--]--> Вызов виртуальных методов, свойств и событий в CLR <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#разумное-использование-видимости-типов-и-модификаторов-доступа-к-членам" aria-label="Разумное использование видимости типов и модификаторов доступа к членам"><!--[--><!--[--><!--]--> Разумное использование видимости типов и модификаторов доступа к членам <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#работа-с-виртуальными-методами-при-управлении-версиями-типов" aria-label="Работа с виртуальными методами при управлении версиями типов"><!--[--><!--[--><!--]--> Работа с виртуальными методами при управлении версиями типов <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch07_ConstantsAndFields.html" aria-label="Константы и поля"><!--[--><!--[--><!--]--> Константы и поля <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch08_Methods.html" aria-label="Методы"><!--[--><!--[--><!--]--> Методы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch09_Parameters.html" aria-label="Параметры"><!--[--><!--[--><!--]--> Параметры <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch10_Properties.html" aria-label="Свойства"><!--[--><!--[--><!--]--> Свойства <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch11_Events.html" aria-label="События"><!--[--><!--[--><!--]--> События <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch12_Generics.html" aria-label="Обобщения"><!--[--><!--[--><!--]--> Обобщения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch13_Interfaces.html" aria-label="Интерфейсы"><!--[--><!--[--><!--]--> Интерфейсы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch14_CharStringText.html" aria-label="Символы, строки и обработка текста"><!--[--><!--[--><!--]--> Символы, строки и обработка текста <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch15_EnumeratedTypes.html" aria-label="Перечислимые типы и битовые флаги"><!--[--><!--[--><!--]--> Перечислимые типы и битовые флаги <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch16_Arrays.html" aria-label="Массивы"><!--[--><!--[--><!--]--> Массивы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch17_Delegates.html" aria-label="Делегаты"><!--[--><!--[--><!--]--> Делегаты <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch18_CustomAttributes.html" aria-label="Настраиваемые атрибуты"><!--[--><!--[--><!--]--> Настраиваемые атрибуты <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch19_NullableValueTypes.html" aria-label="Null-совместимые значимые типы"><!--[--><!--[--><!--]--> Null-совместимые значимые типы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch20_ExceptionsAndStateManae.html" aria-label="Исключения и управление состоянием"><!--[--><!--[--><!--]--> Исключения и управление состоянием <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch21_ManagedHeapGarbage.html" aria-label="Автоматическое управление памятью (сборка мусора)"><!--[--><!--[--><!--]--> Автоматическое управление памятью (сборка мусора) <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch22_CLRHostingAndAppDomain.html" aria-label="Хостинг CLR и домены приложений"><!--[--><!--[--><!--]--> Хостинг CLR и домены приложений <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch23_AssemblyLoaingReflection.html" aria-label="Загрузка сборок и отражение"><!--[--><!--[--><!--]--> Загрузка сборок и отражение <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch24_RuntimeSerialization.html" aria-label="Сериализация"><!--[--><!--[--><!--]--> Сериализация <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch25_WinRTComponents.html" aria-label="Взаимодействие с компонентами WinRT"><!--[--><!--[--><!--]--> Взаимодействие с компонентами WinRT <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch26_ThreadBasics.html" aria-label="Потоки исполнения"><!--[--><!--[--><!--]--> Потоки исполнения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch27_ComputeBoundAsync.html" aria-label="Асинхронные вычислительные операции"><!--[--><!--[--><!--]--> Асинхронные вычислительные операции <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch28_IOBoundAsyncOperations.html" aria-label="Асинхронные операции ввода-вывода"><!--[--><!--[--><!--]--> Асинхронные операции ввода-вывода <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch29_PrimitiveThreadSyncConstructs.html" aria-label="Примитивные конструкции синхронизации потоков"><!--[--><!--[--><!--]--> Примитивные конструкции синхронизации потоков <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch30_hybridThreadSyncConst.html" aria-label="Гибридные конструкции синхронизации потоков"><!--[--><!--[--><!--]--> Гибридные конструкции синхронизации потоков <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="основные-сведения-о-членах-и-типах" tabindex="-1"><a class="header-anchor" href="#основные-сведения-о-членах-и-типах"><span>Основные сведения о членах и типах</span></a></h1><h2 id="члены-типа" tabindex="-1"><a class="header-anchor" href="#члены-типа"><span>Члены типа</span></a></h2><p>В типе можно определить следующие члены:</p><ul><li><strong>Константа</strong> - идентификатор, определяющий некоторую постоянную величину; используются, чтобы упростить чтение кода и для удобства сопровождения и поддержки; константы связаны с типом, а не с экземпляром; на логическом уровне всегда являются статическими членами.</li><li><strong>Поле</strong> - значение данных для чтения и/или записи; может быть статическим, тогда оно является частью состояния типа, или экземплярным - тогда является состоянием конкретного объекта; доступ к полям стоит ограничивать.</li><li><strong>Конструктор экземпляров</strong> - служит для инициализации полей при создании экземпляра.</li><li><strong>Конструктор типа</strong> - служит для инициализации статических полей типа.</li><li><strong>Метод</strong> - функция, выполняющая операции, которые заменяют или запрашивают состояние типа (статический метод) или объекта (экземплярный метод).</li><li><strong>Перегруженный оператор</strong> - определяет поведение, которое необходимо проделать с объектом при применении к нему конкретного оператора; не входит в CLS.</li><li><strong>Оператор преобразования</strong> - метод, задающий порядок явного или неявного преобразования объекта из одного типа в другой; не входит в CLS.</li><li><strong>Свойство</strong> - механизм, позволяющий применить простой синтаксис для получения или установки части логического состояния типа или объекта с контролем логической целостности; бывают необобщёнными и обобщёнными (индексатор - редкий случай, в основном в классах коллекций); в метаданных создаёт два метода с префиксами <code>get_</code> и <code>set_</code>.</li><li><strong>Событие</strong> - механизм, позволяющий типу отправлять уведомления статическим или экземплярным методам; события инициируются в ответ на изменение состояния типа или объекта; состоит из двух методов: регистрации и отмены подписки на событие; использует поле-делегат для управления набором зарегистрированных методов; в метаданных создаёт само событие, а также два метода с префиксами <code>add_</code> и <code>remove_</code>.</li><li><strong>Тип</strong> - определяет вложенные типы; применяется для разбиения большого, сложного типа на небольшие блоки с целью упростить реализацию.</li></ul><h2 id="видимость-типа" tabindex="-1"><a class="header-anchor" href="#видимость-типа"><span>Видимость типа</span></a></h2><p>При определении типа с видимостью в рамках файла, а не другого типа, его можно сделать <em>открытым</em> (public) или <em>внутренним</em> (internal). По умолчанию компилятор C# делает тип внутренним, доступным только внутри сборки</p><h3 id="дружественные-сборки" tabindex="-1"><a class="header-anchor" href="#дружественные-сборки"><span>Дружественные сборки</span></a></h3><p>Иногда случается ситуация, когда необходимо сделать типы из одной сборки видимыми для другой сборки, при этом не делая их общедоступными. Для этого есть механизм <em>дружественных сборок</em> (friend assemblies). Дружественная сборка определяется именем и открытым ключом.</p><h2 id="доступ-к-членам-типов" tabindex="-1"><a class="header-anchor" href="#доступ-к-членам-типов"><span>Доступ к членам типов</span></a></h2><p>При определении члена типа можно указать модификатор доступа к члену. Модификаторы определяют, на какие члены можно ссылаться из кода. В CLR имеется свой набор возможных модификаторов, но в каждом языке свой синтаксис и термины. Ниже представлено шесть модификаторов: от максимального ограничения доступности до минимального.</p><table><thead><tr><th>CLR</th><th>C#</th><th>Описание</th></tr></thead><tbody><tr><td>Private (закрытый)</td><td>private</td><td>Доступен только внутри типа и вложенных типов</td></tr><tr><td>Family (родовой)</td><td>protected</td><td>Доступен только методам в определяющем типе (прим. <em>здесь и далее определяющий тип ВКЛЮЧАЕТ вложенные типы</em>) или в одном из производных типов независимо от сборки</td></tr><tr><td>Family and Assembly (родовой и сборочный)</td><td>private protected (начиная с C# 7.2)</td><td>Доступен в определяющем типе и производных типах в определяющей сборке</td></tr><tr><td>Assembly (сборочный)</td><td>internal</td><td>Доступен в определяющей сборке</td></tr><tr><td>Assembly or Family (сборочный или родовой)</td><td>protected internal</td><td>Доступен во вложенном и производном типах, а также в определяющей сборки</td></tr><tr><td>Public (открытый)</td><td>public</td><td>Доступен всем методами во всех сборках</td></tr></tbody></table><p>Верификация IL-кода гарантирует правильность обработки модификаторов доступа к членам в период выполнения, даже если компилятор проигнорировал эту проверку.</p><p>Если модификатор доступа не указан явно, то компилятор применяет наиболее строгий из всех - <code>private</code>. Начиная с C# 8 можно явно указывать модификаторы доступа к членам интерфейса, теперь они не обязательно должны быть открытыми, как раньше.</p><p>Компилятор C# требует, чтобы у членов базового и производного типов были одинаковые модификаторы доступа. При наследовании позволено снижать, но не повышать ограничения доступности члена, так как разработчик мог бы легко получить доступ к методу через приведение к базовому типу.</p><h2 id="статические-классы" tabindex="-1"><a class="header-anchor" href="#статические-классы"><span>Статические классы</span></a></h2><p>Существуют классы, не предназначенные для создания экземпляров. В сущности, они нужны для группировки логически связанных членов. В C# такие классы определяются ключевым словом <code>static</code>. Его разрешается применять только к классам, но не структурам, так как CLR всегда разрешает создавать экземпляры значимых типов и нет способа обойти это ограничение.</p><p>Компилятор накладывает на статический класс ряд ограничений:</p><ul><li>Класс должен быть прямым потомком <code>System.Object</code> - наследование от любого другого класса не имеет смысла, так как наследование применимо к объектам, а создать экземпляр статического класса невозможно.</li><li>Класс не должен реализовывать никаких интерфейсов, так как методы интерфейса можно вызвать через экземпляры класса.</li><li>В классе можно определять только статические члены. Любые экземплярные члены вызовут ошибку компиляции.</li><li>Класс нельзя использовать в качестве поля, параметра метода или локальной переменной, так как это подразумевает существование экземпляра. В этом случае компилятор вернёт сообщение об ошибке.</li></ul><h2 id="частичные-классы-структуры-и-интерфеисы" tabindex="-1"><a class="header-anchor" href="#частичные-классы-структуры-и-интерфеисы"><span>Частичные классы, структуры и интерфейсы</span></a></h2><p>Ключевое слово <code>partial</code> говорит компилятору C#, что исходный код типа может располагаться в нескольких файлах. Компилятор собирает их вместе на этапе компиляции, так как CLR работает с полными определениями типов. Для использования частичных классов есть три основные причины:</p><ul><li><strong>Управление версиями.</strong> Частичные классы используют, когда над одним типом могут трудиться несколько разработчиков. Разделение на частичные классы может избежать конфликтов.</li><li><strong>Разделение типа на логические модули внутри файла.</strong> Иногда требуется создать один тип для решения разных задач. Тогда этот тип можно разделить и в каждой части реализовать аспект, который необходим в данном случае. Это позволяет упростить наблюдение за членами, обеспечивающими единую функциональность и объединёнными в группу.</li><li><strong>Разделители кода.</strong> Иногда часть кода генерируется автоматически при создании проекта. И чтобы этот код не смешивался с исходным кодом разработчика, его выносят в отдельный частичный класс.</li></ul><p>Частичные типы реализуются только компилятором C#, так что все файлы с исходным кодом должны быть написаны на одном языке.</p><h2 id="компоненты-полиморфизм-и-версии" tabindex="-1"><a class="header-anchor" href="#компоненты-полиморфизм-и-версии"><span>Компоненты, полиморфизм и версии</span></a></h2><p>ООП существует уже давно. В поздние 70-е и ранние 80-е годы приложения были гораздо меньше и разрабатывались в одной компании Современные же приложения состоят из компонентов, разработанных многими компаниями. Компоненты объединяются в приложение в рамках ООП.</p><p>При компонентной разработке (Component Software Programming, CSP) идеи ООП используются на уровне компонентов. Вот основные их свойства:</p><ul><li>Компонент (сборка в .NET) можно публиковать.</li><li>Компоненты уникальны и идентифицируются по имени, версии, региональным стандартам и открытому ключу.</li><li>Компонент сохраняет свою уникальность (код одной сборки никогда статически не связывается с другой сборкой, в .NET используется динамическое связывание).</li><li>В компоненте всегда чётко указана зависимость от других компонентов (ссылочные таблицы метаданных).</li><li>В компоненте документированы его классы и члены. В C# даже разрешается включать в код компонента XML-документацию.</li><li>В компоненте определяются требуемые разрешения на доступ. Для этого в CLR существует механизм защиты доступа к коду (Code Access Security, CAS).</li><li>Опубликованный компонентном интерфейс (объектная модель) не изменяется в его служебных версиях. <em>Служебной версией</em> (servicing) называют новую версию компонента, обратно совместимую с оригинальной. Обычно служебная версия содержит исправления ошибок, но не новые зависимости или разрешения безопасности.</li></ul><p>В компонентном программировании большое внимание уделяют управлению версиями. В компоненты вносятся изменения, они поставляются в разное время. Это существенно усложняет компонентное программирование по сравнению с классическим ООП, где всё приложение пишет, тестирует и поставляет одна компания.</p><p>В .NET номер версии состоит из четырёх частей: <em>основного</em> (major), <em>дополнительного</em> (minor), номер <em>построения</em> (build) и номер <em>редакции</em> (revision). В случае изменения функциональности меняются основной и дополнительный номера, в случае исправлений - построения и редакции.</p><p>Проблемы управления версиями возникают, когда тип, определённый в одном компоненте, является базовым для типа в другом компоненте. Эти проблемы особенно характерны для полиморфизма, когда в производном типе переопределяются виртуальные методы.</p><p>В C# есть пять ключевых слов, которые непосредственно связаны с управлением версиями.</p><h5 id="модификаторы-наследования" tabindex="-1"><a class="header-anchor" href="#модификаторы-наследования"><span>Модификаторы наследования</span></a></h5><table><thead><tr><th>Ключевое слово C#</th><th>Тип</th><th>Метод/Свойство/Событие</th><th>Константа/Поле</th></tr></thead><tbody><tr><td>abstract</td><td>Нельзя создать экземпляр этого типа.</td><td>Член необходимо переопределить и реализовать в производном типе - после этого можно создать экземпляр производного типа.</td><td>(запрещено)</td></tr><tr><td>virtual</td><td>(запрещено)</td><td>Член можно переопределять в производном типе</td><td>(запрещено)</td></tr><tr><td>override</td><td>(запрещено)</td><td>Член переопределяется в производном типе</td><td>(запрещено)</td></tr><tr><td>sealed</td><td>Тип нельзя использовать в качестве базового.</td><td>Член нельзя переопределить в производном типе. Можно применить только к методу, переопределяющему виртуальный метод.</td><td>(запрещено)</td></tr><tr><td>new</td><td colspan="3">Означает, что член никак не связан с похожим членом из базового класса (применяется по умолчанию при описании члена с похожим названием)</td></tr></tbody></table><h3 id="вызов-виртуальных-методов-своиств-и-событии-в-clr" tabindex="-1"><a class="header-anchor" href="#вызов-виртуальных-методов-своиств-и-событии-в-clr"><span>Вызов виртуальных методов, свойств и событий в CLR</span></a></h3><p>Методы содержат код, выполняющий некоторые действия над типом (статические методы) или над объектом (экземплярные методы). У каждого метода есть имя, сигнатура и возвращаемый тип (иногда может быть пустым, <code>void</code>). У типа может быть несколько методов с одинаковым именем, но с разным числом параметров или с разными возвращаемыми значениями. Можно также объявить метод с одними и теми же именем и параметрами, но с разными возвращаемыми значениями (хотя большинство языков это не используют, за исключением IL).</p><p>Есть класс с тремя различными вариантами методов:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Невиртуальный экземплярный метод</span>
    <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> GetYearsEmployed <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// Виртуальный метод (виртуальный - значит, экземплярный)</span>
    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">String</span> GetProgressReport <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// Статический метод</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Employee</span> <span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>При компиляции этого кода компилятор помещает три записи в таблицу определений методов сборки. Каждая запись содержит флаги, указывающие, является ли метод экземплярным, виртуальным или статическим.</p><p>При компиляции кода, ссылающегося на эти методы, компилятор проверяет флаги, чтобы определить, какой IL-код необходимо вставить для корректного вызова. В CLR есть две инструкции для вызова методов:</p><ul><li>Инструкция <code>call</code> используется для вызова любых методов. Если вызвался статический метод, то необходимо указать тип, где определяется метод. При вызове экземплярного или виртуального метода необходимо указать переменную, ссылающуюся на объект (подразумевается, что переменная не <code>null</code>). Сам тип переменной указывает, в каком типе определён необходимый метод. Если метод не определён в типе, то проверяются базовые типы. Инструкция часто используется для невиртуального вызова виртуальных методов.</li><li>Инструкция <code>callvirt</code> используется для вызова экземплярных и виртуальных методов. При вызове необходимо указать переменную. Если с помощью этой инструкции вызывается невиртуальный метод, тип показывает, где определён метод. При вызове виртуального метода, CLR определяет настоящий тип объекта и вызывает метод полиморфно. При компиляции такого метода происходит проверка на <code>null</code>, из-за чего метод работает чуть медленнее.</li></ul><p>Компилятор C# часто использует именно инструкцию <code>callvirt</code> для вызова невиртуальных экземплярных методов, чтобы спровоцировать проверку на <code>null</code>.</p><p>Компиляторы стремятся использовать инструкцию <code>call</code> для вызова методов значимого типа, потому что они запечатаны. В этом случае полиморфизм невозможен, как и нуллабильность этого объекта по природе его типа. Наконец, для виртуального вызова виртуального метода значимого типа необходима упаковка, что увеличит частоту сборки мусора и снизит производительность.</p><p>При проектировании типов стоит стремиться свести к минимуму число виртуальных методов, так как они замедляют приложение и усложняют контроль версий. Виртуальный стоит делать только наиболее функциональный метод в типе.</p><h3 id="разумное-использование-видимости-типов-и-модификаторов-доступа-к-членам" tabindex="-1"><a class="header-anchor" href="#разумное-использование-видимости-типов-и-модификаторов-доступа-к-членам"><span>Разумное использование видимости типов и модификаторов доступа к членам</span></a></h3><p>Автор считает, что компилятором стоит по умолчанию делать классы запечатанными по следующим причинам:</p><ul><li><strong>Управление версиями.</strong> Если класс изначально сделан запечатанным, то его впоследствии можно сделать незапечатанным, не нарушая совместимости. Однако обратное невозможно. Кроме того, если в незапечатанном классе определены незапечатанные виртуальные методы, необходимо сохранять порядок вызовов, иначе в будущем возникнут проблемы с производными типами.</li><li><strong>Производительность.</strong> При вызове виртуального метода в запечатанном типе, JIT-компилятор может задействовать невиртуальный вызов, так как у типа не может быть наследников.</li><li><strong>Безопасность и предсказуемость.</strong> Состояние класса должно быть надёжно защищено. Производный тип может изменять состояние базового через открытые методы и свойства.</li></ul><p>Несколько правил проектирования типов:</p><ul><li>Если класс не предназначен для наследования, его стоит запечатывать.</li><li>Все поля класса должны быть закрытыми.</li><li>Методы, свойства и события стоит объявлять закрытыми и невиртуальными. Естественно, часть методов должна быть открыта для работы с классом, но лучше не делать их защищёнными или внутренними. Хотя защищённый или внутренний член всё-таки лучше виртуального, поскольку последний предоставляет производному классу больший контроль над своим поведением.</li><li>В ООП есть принцип: &quot;Лучший метод борьбы со сложностью - добавление новых типов&quot;. Однако новые типы стоит создавать рядом, а не внутри, чтобы не усложнять обращение к вложенным типам.</li></ul><h3 id="работа-с-виртуальными-методами-при-управлении-версиями-типов" tabindex="-1"><a class="header-anchor" href="#работа-с-виртуальными-методами-при-управлении-версиями-типов"><span>Работа с виртуальными методами при управлении версиями типов</span></a></h3><p>Описывается пример, когда тип, написанный в одной компании, является производным от типа, написанного в другой компании. Здесь же описываются все те действия, через которые приходится проходить разработчикам при изменениях в исходном коде обоих типов.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="external-link label" href="https://github.com/arytry/clr-via-csharp/edit/main/docs/ru/chapters/ch06_TypeAndMemberBasics.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--[--><svg class="icon" viewBox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link prev" href="/clr-via-csharp/ru/chapters/ch05_PrimitiveRefValType.html" aria-label="Примитивные, ссылочные и значимые типы"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span>Примитивные, ссылочные и значимые типы</span></div><!--]--></a><a class="route-link next" href="/clr-via-csharp/ru/chapters/ch07_ConstantsAndFields.html" aria-label="Константы и поля"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>Константы и поля</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/clr-via-csharp/assets/app-IxoMmWNN.js" defer></script>
  </body>
</html>
