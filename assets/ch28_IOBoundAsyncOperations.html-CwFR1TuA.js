import{_ as n,o as s,c as a,e}from"./app-IxoMmWNN.js";const t={},p=e(`<h1 id="асинхронные-операции-ввода-вывода" tabindex="-1"><a class="header-anchor" href="#асинхронные-операции-ввода-вывода"><span>Асинхронные операции ввода-вывода</span></a></h1><h2 id="операции-ввода-вывода-в-windows" tabindex="-1"><a class="header-anchor" href="#операции-ввода-вывода-в-windows"><span>Операции ввода-вывода в Windows</span></a></h2><p>В процессе выполнения устройством операции ввода-вывода поток исполнения, передавший запрос, простаивает, поэтому Windows переводит его в спящее состояние, чтобы не расходовать процессорное время. Однако при этом поток продолжает занимать место в памяти своими структурами. После завершение операции ввода-выводы Windows пробуждает поток, ставит его в очередь процессора.</p><p>Можно представить реализацию веб-приложения, в которой для каждого пришедшего на сервер клиентского запроса формируется запрос к базе данных. В случае синхронного запроса к базе поток из пула окажется заблокированным на время, необходимое для чтения данных из базы. Если в это время придёт ещё один клиентский запрос, пул создаст новый поток. Таким образом потребление ресурсов продолжит расти. Проблема усугубится тем, что при получении результатов из базы несколько потоков могут разблокироваться одновременно, и их число может оказаться выше числа процессоров, что приведёт к частым переключениям контекста.</p><p><img src="https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/dac07c85-dd6f-4cd7-94ca-8581c701ccae" alt="image"></p><p>В качестве альтернативы есть способ асинхронного чтения данных.</p><p><img src="https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/52e54376-8863-4dda-be4e-7cf1c3274339" alt="image"></p><p>В случае асинхронных операций ввода-вывода в веб-приложении поток не блокируется, а возвращается в пул и может заняться обработкой других клиентский запросов. В этом случае все запросы может обработать один поток. Полученный от базы ответ окажется в очереди пула потоков, то есть его обработает тот же поток. Если элементы в пуле будут появляться быстрее, чем поток сможет их обработать, пул быстро создаст по одному потоку на каждый процессор.</p><p>Однако при блокировке потока (выполнение синхронной операции ввода-вывода, вызове метода <code>Thread.Sleep()</code> или ожидании, связанном с блокировкой потока в рамках синхронизации) пул будет уведомлен, что один из потоков прекратил работу. В этом случае создастся дополнительный поток взамен заблокированного, что приведёт к дополнительным затратам времени и памяти. Кроме того, позднее поток может быть разблокирован и процессор окажется перегруженным, провоцируя частые переключения контекста. Эта проблема решается средствами пула. Завершившим и вернувшимся в пул потокам не дают обрабатывать новые элементы, пока загрузка процессора не достигнет определённого уровня. Если впоследствии выяснится, что потоков больше, чем нужно, лишние самоуничтожатся.</p><p>Асинхронный ввод-вывод предоставляет и другие преимущества. CLR в начале сборки мусора приостанавливает все потоки, следовательно, чем меньше потоков, тем быстрее произойдёт сборка мусора. Также при сборке будет просматриваться меньше стеков потоков. Также если потоки не были заблокированы, то они окажутся в пуле наверху стека, и поиск корней не займёт много времени. По аналогичным же причинам ускоряется и отладка приложений.</p><h2 id="асинхронные-функции-c" tabindex="-1"><a class="header-anchor" href="#асинхронные-функции-c"><span>Асинхронные функции C#</span></a></h2><p>Асинхронные операции являются ключом к созданию высокопроизводительных масштабируемых приложений, выполняющих множество операций при помощи небольшого числа потоков. Вместе с пулом потоков они позволяют эффективно задействовать все процессоры в системе. Для этого разработчики CLR разработали модель программирования, основанную на <code>Task</code> и <em>асинхронных функциях</em> языка C#.</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> <span class="token function">IssueClientRequestAsync</span><span class="token punctuation">(</span><span class="token class-name">String</span> serverName<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> pipe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NamedPipeClientStream</span><span class="token punctuation">(</span>serverName<span class="token punctuation">,</span> <span class="token string">&quot;PipeName&quot;</span><span class="token punctuation">,</span> PipeDirection<span class="token punctuation">.</span>InOut<span class="token punctuation">,</span> PipeOptions<span class="token punctuation">.</span>Asynchronous <span class="token operator">|</span> PipeOptions<span class="token punctuation">.</span>WriteThrough<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    pipe<span class="token punctuation">.</span><span class="token function">Connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Прежде чем задавать ReadMode, необходимо</span>
    pipe<span class="token punctuation">.</span>ReadMode <span class="token operator">=</span> PipeTransmissionMode<span class="token punctuation">.</span>Message<span class="token punctuation">;</span> <span class="token comment">// вызвать Connect</span>

    <span class="token comment">// Асинхронная отправка данных серверу</span>
    <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> request <span class="token operator">=</span> Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetBytes</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> pipe<span class="token punctuation">.</span><span class="token function">WriteAsync</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Асинхронное чтение ответа сервера</span>
    <span class="token class-name">Byte<span class="token punctuation">[</span><span class="token punctuation">]</span></span> response <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">Int32</span> bytesRead <span class="token operator">=</span> <span class="token keyword">await</span> pipe<span class="token punctuation">.</span><span class="token function">ReadAsync</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> response<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetString</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesRead<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token comment">// Закрытие канала</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Асинхронная функция помечается ключевым словом <code>async</code>. Такой метод преобразуется компилятором в конечных автомат. Это позволяет потоку выполнить часть кода в конечном автомате, а затем вернуть управления без выполнения всего метода до завершения. Когда выполнение метода доходит до строки с ключевым словом <code>await</code>, вызывается метод <code>Task.ContinueWith()</code> с передачей метода, возобновляющее выполнение конечного автомата, после чего поток возвращает управление из асинхронного метода.</p><p>В будущем драйвер сетевого устройства завершит запись данных в канал, поток из пула оповестит об этом <code>Task</code>, что приведёт к активизации метода обратного вызова <code>ContinueWith()</code>, заставляющего поток возобновить выполнение конечного автомат. Если конкретнее, поток заново входит в асинхронный метод, но в точке оператора <code>await</code>. Теперь выполнится сгенерированный компилятором код, запрашивающий состояние объекта <code>Task</code>. Если операция завершается успешно, оператор <code>await</code> возвращает результат. Аналогичная ситуация произойдёт со следующим оператором <code>await</code>. После чего выполнится оставшаяся часть кода, а сборщик мусора при необходимости освободит память.</p><p>Так как асинхронные функции возвращают управление до того, как их конечный автомат отработает до завершения, выполнение метода, вызвавшего асинхронную функцию, продолжится сразу после того, как функция выполнит свой первый оператор <code>await</code>. Вызывающая сторона узнает, что выполнение конечного автомата завершилось, так как при пометке метода ключевым словом <code>async</code> компилятор генерирует код, создающий <code>Task</code> в начале выполнения автомата, который завершится при завершении конечного автомата.</p><p>Для асинхронных функций действует ряд ограничений:</p><ul><li>Метод <code>Main()</code> не может быть асинхронным. Кроме того, асинхронными не могут быть конструкторы, методы доступа свойств и методы доступа событий.</li><li>Асинхронная функция не может иметь параметры <code>out</code> и <code>ref</code>.</li><li>Оператор <code>await</code> не может использоваться в блоках <code>catch</code>, <code>finally</code> или <code>unsafe</code>.</li><li>Не допускается установление блокировки, поддерживающей владение потоком или рекурсию, до операции <code>await</code> и её снятие после этого оператора. Это объясняется тем, что один поток может выполнять код до <code>await</code>, а другой - после. При использовании <code>await</code> с конструкцией C# <code>lock</code> компилятор выдаёт сообщение об ошибке. Если вместо этого явно вызвать методы <code>Monitor.Enter()</code> и <code>Monitor.Exit()</code>, то код скомпилируется, то во время выполнения возникнет исключение.</li><li>В выражениях запросов оператор <code>await</code> может использоваться только в первом выражении коллекции условия <code>from</code> или в выражении коллекции условия <code>join</code>.</li></ul><p>Обо всех этих ограничениях сообщает компилятор.</p><h2 id="преобразование-асинхроннои-функции-в-конечныи-автомат" tabindex="-1"><a class="header-anchor" href="#преобразование-асинхроннои-функции-в-конечныи-автомат"><span>Преобразование асинхронной функции в конечный автомат</span></a></h2><p>Исходный код:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Type1</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Type2</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>Type1<span class="token punctuation">&gt;</span></span> <span class="token function">Method1Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Асинхронная операция, возвращающая объект Type1 */</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>Type2<span class="token punctuation">&gt;</span></span> <span class="token function">Method2Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Асинхронная операция, возвращающая объект Type2 */</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> <span class="token function">MyMethodAsync</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> argument<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Int32</span> local <span class="token operator">=</span> argument<span class="token punctuation">;</span>
  <span class="token keyword">try</span>
  <span class="token punctuation">{</span>
    <span class="token class-name">Type1</span> result1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">Method1Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Int32</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token class-name">Type2</span> result2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">Method2Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Catch&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span>
  <span class="token punctuation">{</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Finally&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token string">&quot;Done&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Код конечного автомата:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">// Атрибут AsyncStateMachine обозначает асинхронный метод (полезно для инструментов, использующих отражение);</span>
<span class="token comment">// тип указывает, какая структура реализует конечный автомат.</span>
<span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">DebuggerStepThrough</span><span class="token punctuation">,</span> <span class="token class-name">AsyncStateMachine</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">StateMachine</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> <span class="token function">MyMethodAsync</span><span class="token punctuation">(</span><span class="token class-name">Int32</span> argument<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// Создание экземпляра конечного автомата и его инициализация</span>
  <span class="token class-name">StateMachine</span> stateMachine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StateMachine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Создание построителя, возвращающего Task&lt;String&gt;.</span>
    <span class="token comment">// Конечный автомат обращается к построителю для назначения завершения задания или выдачи исключения.</span>
    m_builder <span class="token operator">=</span> AsyncTaskMethodBuilder<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    m_state <span class="token operator">=</span> ­<span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// инициализация местонахождения</span>
    m_argument <span class="token operator">=</span> argument <span class="token comment">// Копирование аргументов в поля конечного автомата</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// Начало выполнения конечного автомата.</span>
  stateMachine<span class="token punctuation">.</span>m_builder<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token keyword">ref</span> stateMachine<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> stateMachine<span class="token punctuation">.</span>m_builder<span class="token punctuation">.</span>Task<span class="token punctuation">;</span> <span class="token comment">// Возвращение задания конечного автомата</span>
<span class="token punctuation">}</span> 

<span class="token comment">// Структура конечного автомата</span>
<span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">CompilerGenerated</span><span class="token punctuation">,</span> <span class="token class-name">StructLayout</span><span class="token attribute-arguments"><span class="token punctuation">(</span>LayoutKind<span class="token punctuation">.</span>Auto<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
<span class="token keyword">private</span> <span class="token keyword">struct</span> <span class="token class-name">StateMachine</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IAsyncStateMachine</span></span>
<span class="token punctuation">{</span>
  <span class="token comment">// Поля для построителя конечного автомата (Task) и его местонахождения</span>
  <span class="token keyword">public</span> <span class="token class-name">AsyncTaskMethodBuilder<span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> m_builder<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_state<span class="token punctuation">;</span>

  <span class="token comment">// Аргумент и локальные переменные становятся полями:</span>
  <span class="token keyword">public</span> <span class="token class-name">Int32</span> m_argument<span class="token punctuation">,</span> m_local<span class="token punctuation">,</span> m_x<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">Type1</span> m_resultType1<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token class-name">Type2</span> m_resultType2<span class="token punctuation">;</span>

  <span class="token comment">// Одно поле на каждый тип Awaiter.</span>
  <span class="token comment">// В любой момент времени важно только одно из этих полей.</span>
  <span class="token comment">// В нем хранится ссылка на последний выполненный экземпляр await, который завершается асинхронно:</span>
  <span class="token keyword">private</span> <span class="token class-name">TaskAwaiter<span class="token punctuation">&lt;</span>Type1<span class="token punctuation">&gt;</span></span> m_awaiterType1<span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">TaskAwaiter<span class="token punctuation">&lt;</span>Type2<span class="token punctuation">&gt;</span></span> m_awaiterType2<span class="token punctuation">;</span>

  <span class="token comment">// Сам конечный автомат</span>
  <span class="token return-type class-name"><span class="token keyword">void</span></span> IAsyncStateMachine<span class="token punctuation">.</span><span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token class-name">String</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Результат Task</span>

    <span class="token comment">// Вставленный компилятором блок try гарантирует завершение задания конечного автомата</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
      <span class="token class-name">Boolean</span> executeFinally <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// Логический выход из блока &#39;try&#39;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>m_state <span class="token operator">==</span> ­<span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>                       <span class="token comment">// Если метод конечного автомата выполняется впервые</span>
        m_local <span class="token operator">=</span> m_argument<span class="token punctuation">;</span> <span class="token comment">// Выполнить начало исходного метода</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// Блок try из исходного кода</span>
      <span class="token keyword">try</span>
      <span class="token punctuation">{</span>
        <span class="token class-name">TaskAwaiter<span class="token punctuation">&lt;</span>Type1<span class="token punctuation">&gt;</span></span> awaiterType1<span class="token punctuation">;</span>
        <span class="token class-name">TaskAwaiter<span class="token punctuation">&lt;</span>Type2<span class="token punctuation">&gt;</span></span> awaiterType2<span class="token punctuation">;</span>

        <span class="token keyword">switch</span> <span class="token punctuation">(</span>m_state<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          <span class="token keyword">case</span> ­<span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment">// Начало исполнения кода в &#39;try&#39;</span>
          <span class="token comment">// вызвать Method1Async и получить его объект ожидания</span>
          awaiterType1 <span class="token operator">=</span> <span class="token function">Method1Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>awaiterType1<span class="token punctuation">.</span>IsCompleted<span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
            m_state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Method1Async&#39; завершается асинхронно</span>
            m_awaiterType1 <span class="token operator">=</span> awaiterType1<span class="token punctuation">;</span> <span class="token comment">// Сохранить объект ожидания до возвращения</span>
            <span class="token comment">// Приказать объекту ожидания вызвать MoveNext после завершения операции</span>
            m_builder<span class="token punctuation">.</span><span class="token function">AwaitUnsafeOnCompleted</span><span class="token punctuation">(</span><span class="token keyword">ref</span> awaiterType1<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Предыдущая строка вызывает метод OnCompleted объекта awaiterType1, что приводит к вызову ContinueWith(t =&gt; MoveNext()) для Task.</span>
            <span class="token comment">// При завершении Task ContinueWith вызывает MoveNext</span>
            executeFinally <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Без логического выхода из блока &#39;try&#39;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// Поток возвращает управление вызывающей стороне</span>
          <span class="token punctuation">}</span>

          <span class="token comment">// &#39;Method1Async&#39; завершается синхронно.</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>

          <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment">// &#39;Method1Async&#39; завершается асинхронно</span>
            awaiterType1 <span class="token operator">=</span> m_awaiterType1<span class="token punctuation">;</span> <span class="token comment">// Восстановление последнего объекта ожидания</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> 

          <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment">// &#39;Method2Async&#39; завершается асинхронно</span>
            awaiterType2 <span class="token operator">=</span> m_awaiterType2<span class="token punctuation">;</span> <span class="token comment">// Восстановление последнего объекта ожидания</span>
            <span class="token keyword">goto</span> ForLoopEpilog<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// После первого await сохраняем результат и запускаем цикл &#39;for&#39;</span>
        m_resultType1 <span class="token operator">=</span> awaiterType1<span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Получение результата</span>

        ForLoopPrologue<span class="token punctuation">:</span>
          m_x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Инициализация цикла &#39;for&#39;</span>
          <span class="token keyword">goto</span> ForLoopBody<span class="token punctuation">;</span> <span class="token comment">// Переход к телу цикла &#39;for&#39;</span>

        ForLoopEpilog<span class="token punctuation">:</span>
          m_resultType2 <span class="token operator">=</span> awaiterType2<span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          m_x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// Увеличение x после каждой итерации</span>

        <span class="token comment">// Переход к телу цикла &#39;for&#39;</span>
        ForLoopBody<span class="token punctuation">:</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>m_x <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span> <span class="token comment">// Условие цикла &#39;for&#39;</span>
            <span class="token comment">// Вызов Method2Async и получение объекта ожидания</span>
            awaiterType2 <span class="token operator">=</span> <span class="token function">Method2Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>awaiterType2<span class="token punctuation">.</span>IsCompleted<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
              m_state <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Method2Async&#39; завершается асинхронно</span>
              m_awaiterType2 <span class="token operator">=</span> awaiterType2<span class="token punctuation">;</span> <span class="token comment">// Сохранение объекта ожидания до возвращения</span>

              <span class="token comment">// Приказываем вызвать MoveNext при завершении операции</span>
              m_builder<span class="token punctuation">.</span><span class="token function">AwaitUnsafeOnCompleted</span><span class="token punctuation">(</span><span class="token keyword">ref</span> awaiterType2<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              executeFinally <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Без логического выхода из блока &#39;try&#39;</span>
              <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// Поток возвращает управление вызывающей стороне</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// &#39;Method2Async&#39; завершается синхронно</span>
            <span class="token keyword">goto</span> ForLoopEpilog<span class="token punctuation">;</span> <span class="token comment">// Синхронное завершение, возврат</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Catch&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">finally</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// Каждый раз, когда блок физически выходит из &#39;try&#39;, выполняется &#39;finally&#39;.</span>
        <span class="token comment">// Этот код должен выполняться только при логическом выходе из &#39;try&#39;.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executeFinally<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Finally&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      result <span class="token operator">=</span> <span class="token string">&quot;Done&quot;</span><span class="token punctuation">;</span> <span class="token comment">// То, что в конечном итоге должна вернуть асинхронная функция.</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment">// Необработанное исключение: задание конечного автомата  завершается с исключением.</span>
      m_builder<span class="token punctuation">.</span><span class="token function">SetException</span><span class="token punctuation">(</span>exception<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Исключения нет: задание конечного автомата завершается с результатом</span>
    m_builder<span class="token punctuation">.</span><span class="token function">SetResult</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Каждый раз, когда в коде используется оператор <code>await</code>, компилятор берёт указанный операнд и пытается вызвать для него метод <code>GetAwaiter()</code>. Он может быть как экземплярным, так и методом расширения. Объект, возвращаемый при вызове этого метода, называется <em>объектом ожидания</em> (awaiter).</p><p>После того, как конечный автомат получает объект ожидания, он запрашивает его свойство <code>IsCompleted</code>. Если операция завершается синхронно, возвращается <code>true</code> и конечный автомат продолжает выполнение. Он вызывает метод <code>GetResult()</code>? который либо выдаёт исключение, либо возвращает результат. Конечный автомат продолжает выполнение для обработки результата.</p><p>Если операция завершается асинхронно, то возвращается <code>false</code>. В этом случае вызывается метод <code>OnCompleted()</code> объекта ожидания, передавая ему делегат метода <code>MoveNext()</code> конечного автомата. И теперь конечный автомат позволяет своему потоку вернуть управление в сходную точку, чтобы тот мог продолжить выполнение другого кода. В будущем объект ожидания узнает о своём завершении и вызывает делегата, что приводит к исполнению <code>MoveNext()</code>. По полям конечного автомата определяется способ перехода к правильной точке кода, что создаёт иллюзию продолжения выполнения метода с того места, с которого он был прерван. На этой стадии код вызывает <code>GetResult()</code> и продолжает выполнение для обработки результата.</p><h2 id="расширяемость-асинхронных-функции" tabindex="-1"><a class="header-anchor" href="#расширяемость-асинхронных-функции"><span>Расширяемость асинхронных функций</span></a></h2><p>Представление всех видов асинхронных операций одним типом <code>Task</code> позволяет реализовывать комбинаторы (<code>Task.WhenAny()</code> и <code>Task.WhenAll()</code>) и другие полезные операции.</p><p>Наряду с гибкостью асинхронные функции предоставляют ещё одну точку расширения: компилятор вызывает <code>GetAwaiter()</code> для операнда, использовавшегося с <code>await</code>. Таким образом, операнд не обязан быть <code>Task</code>, он может относиться к любому типу. содержащему <code>GetAwaiter()</code>.</p><h2 id="асинхронные-функции-и-обработчики-событии" tabindex="-1"><a class="header-anchor" href="#асинхронные-функции-и-обработчики-событии"><span>Асинхронные функции и обработчики событий</span></a></h2><p>Для асинхронных функций возможно определение возвращаемого типа как <code>void</code>. Это особый случай, который поддерживается компилятором для реализации асинхронного обработчика события. В таком случае асинхронна функция превращается в конечный автомат, но не создаёт объект <code>Task</code>, из-за чего нельзя узнать о завершённости задания.</p><p>Метод <code>Main()</code> нельзя пометить ключевым словом <code>async</code> и внутри него нельзя использовать операторы <code>await</code>, так как в этом случае управление вернётся сразу же после выполнения первого оператора <code>await</code>, а поскольку метод <code>Main()</code> не асинхронный, то он не создаёт таску и нельзя будет отследить его завершённость. Для предотвращения подобного поведения компилятор выдаёт ошибку.</p><h2 id="асинхронные-функции-fcl" tabindex="-1"><a class="header-anchor" href="#асинхронные-функции-fcl"><span>Асинхронные функции FCL</span></a></h2><p>Асинхронные функции легко освоить они просты в использовании и поддерживаются многими типами FCL. Кроме того, они сразу видны в коде, так как чаще всего имя метода снабжается суффиксом <code>Async</code>.</p><p>До модели асинхронных функций (TAP, Task-based Asynchronous Pattern) существовали также и другие подходы:</p><ul><li>EAP (Event-based Asynchronous Pattern) — подход основан на событиях, которые срабатывают по завершении операции и обычного метода, вызывающего эту операцию.</li><li>APM (Asynchronous Programming Model) — основан на 2 методах: <code>BeginSmth()</code> возвращает интерфейс <code>IAsyncResult</code>, метод <code>EndSmth()</code> принимает <code>IAsyncResult</code> (если к моменту вызова <code>EndSmth()</code> операция не завершена, поток блокируется).</li></ul><p>В некоторых классах FCL можно встретить APM подход, так как не всё успели переписать под TAP. Если необходимо воспользоваться одним из таких классов, то его можно привести к новой модели с помощью метода <code>Task.Factory.FromAsync()</code>. Если же используется EAP, то в FCL нет вспомогательных методов-адаптеров, поэтому адаптировать придётся вручную.</p><h2 id="асинхронные-функции-и-исключения" tabindex="-1"><a class="header-anchor" href="#асинхронные-функции-и-исключения"><span>Асинхронные функции и исключения</span></a></h2><p>При использовании <code>await</code> с <code>Task</code> вместо <code>AggregateException</code> выдаётся первое внутреннее исключение, чтобы поведение кода соответствовало ожиданиям разработчиков.</p><h2 id="другие-возможности-асинхронных-функции" tabindex="-1"><a class="header-anchor" href="#другие-возможности-асинхронных-функции"><span>Другие возможности асинхронных функций</span></a></h2><p>В разделе рассказывается подробнее про отладку асинхронных функций.</p><p>С помощью <code>Task.Run()</code> можно запустить асинхронную функцию в потоке. отличном от вызывающего.</p><p>Кроме того, в разделе описывается использование асинхронных лямбда-выражений и способы обхода предупреждений компилятора в случае, если внутри асинхронного метода не используется оператор <code>await</code>.</p><h2 id="потоковые-модели-приложении" tabindex="-1"><a class="header-anchor" href="#потоковые-модели-приложении"><span>Потоковые модели приложений</span></a></h2><p>Консольные приложение и Windows-службы не навязывают никакой потоковой модели. Приложение с графическим интерфейсом предлагают такую модель, в которой обновлять окно может только создавший его поток, GUI-потоки обычно порождают асинхронные операции.</p><p>Приложения ASP.NET позволяют любому потоку делать всё, что угодно. Порождённая одним потоком пула асинхронная операция может заканчиваться другим потоком, который обрабатывает её результат. При этом при переходе между потоками должен сохраняться контекст.</p><p>При разработке библиотек классов стоит принимать во внимание класс <code>SynchronizationContext</code>, что позволит создать высокопроизводительный код. Кроме того, при разработке стоит сделать всё возможное, чтобы пользователи библиотеки избежали взаимной блокировки. Для решения этих проблем классы <code>Task</code> и <code>Task&lt;TResult&gt;</code> предоставляют метод <code>ConfigureAwait()</code>. Если передать в этот метод <code>false</code>, то оператор <code>await</code> не запрашивает контекст синхронизации вызывающего потока, а когда поток пула завершает выполнение задания, происходит простое завершение.</p><h2 id="асинхронная-реализация-сервера" tabindex="-1"><a class="header-anchor" href="#асинхронная-реализация-сервера"><span>Асинхронная реализация сервера</span></a></h2><p>В разделе описывается построение асинхронных серверов с хорошей масштабируемостью для:</p><ul><li>Web Forms ASP.NET.</li><li>Асинхронных MVC-контроллеров ASP.NET.</li><li>Асинхронного обработчика ASP.NET.</li><li>Асинхронной службы WCF.</li></ul><h2 id="отмена-операции-ввода-вывода" tabindex="-1"><a class="header-anchor" href="#отмена-операции-ввода-вывода"><span>Отмена операций ввода-вывода</span></a></h2><p>В общем случае не существует возможности отмены затянувшейся операции ввода-вывода, потому что отменить посланный на сервер запрос уже не удастся. Кроме того, может возникнуть ситуация гонки. Если флаг отмены придёт в тот момент, когда сервер пришлёт ответ, то как быть? В разделе Рихтер предлагает реализовать метод расширения, который бы завершал такой <code>Task</code> при отмене.</p><h3 id="некоторые-операции-ввода-вывода-должны-выполняться-синхронно" tabindex="-1"><a class="header-anchor" href="#некоторые-операции-ввода-вывода-должны-выполняться-синхронно"><span>Некоторые операции ввода-вывода должны выполняться синхронно</span></a></h3><p>В разделе описываются ситуации, для которых недоступны асинхронные операции и как их можно избежать.</p><h3 id="проблемы-filestream" tabindex="-1"><a class="header-anchor" href="#проблемы-filestream"><span>Проблемы FileStream</span></a></h3><p>При работе с <code>FileStream</code> стоит заранее выбрать синхронным или асинхронным будет ввод-вывод файлов и установить соответствующий флаг. При этом стоит использовать соответствующий (синхронный или асинхронный) метод.</p><h2 id="приоритеты-запросов-ввода-вывода" tabindex="-1"><a class="header-anchor" href="#приоритеты-запросов-ввода-вывода"><span>Приоритеты запросов ввода-вывода</span></a></h2><p>Windows позволяет указать приоритет потока при выполнении запросов ввода-вывода. В FCL данная функциональность не реализована, на данный момент преимуществами данного функционала можно воспользоваться при помощи механизма P/Invoking.</p>`,59),c=[p];function o(l,i){return s(),a("div",null,c)}const d=n(t,[["render",o],["__file","ch28_IOBoundAsyncOperations.html.vue"]]),k=JSON.parse('{"path":"/ru/chapters/ch28_IOBoundAsyncOperations.html","title":"Асинхронные операции ввода-вывода","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Операции ввода-вывода в Windows","slug":"операции-ввода-вывода-в-windows","link":"#операции-ввода-вывода-в-windows","children":[]},{"level":2,"title":"Асинхронные функции C#","slug":"асинхронные-функции-c","link":"#асинхронные-функции-c","children":[]},{"level":2,"title":"Преобразование асинхронной функции в конечный автомат","slug":"преобразование-асинхроннои-функции-в-конечныи-автомат","link":"#преобразование-асинхроннои-функции-в-конечныи-автомат","children":[]},{"level":2,"title":"Расширяемость асинхронных функций","slug":"расширяемость-асинхронных-функции","link":"#расширяемость-асинхронных-функции","children":[]},{"level":2,"title":"Асинхронные функции и обработчики событий","slug":"асинхронные-функции-и-обработчики-событии","link":"#асинхронные-функции-и-обработчики-событии","children":[]},{"level":2,"title":"Асинхронные функции FCL","slug":"асинхронные-функции-fcl","link":"#асинхронные-функции-fcl","children":[]},{"level":2,"title":"Асинхронные функции и исключения","slug":"асинхронные-функции-и-исключения","link":"#асинхронные-функции-и-исключения","children":[]},{"level":2,"title":"Другие возможности асинхронных функций","slug":"другие-возможности-асинхронных-функции","link":"#другие-возможности-асинхронных-функции","children":[]},{"level":2,"title":"Потоковые модели приложений","slug":"потоковые-модели-приложении","link":"#потоковые-модели-приложении","children":[]},{"level":2,"title":"Асинхронная реализация сервера","slug":"асинхронная-реализация-сервера","link":"#асинхронная-реализация-сервера","children":[]},{"level":2,"title":"Отмена операций ввода-вывода","slug":"отмена-операции-ввода-вывода","link":"#отмена-операции-ввода-вывода","children":[{"level":3,"title":"Некоторые операции ввода-вывода должны выполняться синхронно","slug":"некоторые-операции-ввода-вывода-должны-выполняться-синхронно","link":"#некоторые-операции-ввода-вывода-должны-выполняться-синхронно","children":[]},{"level":3,"title":"Проблемы FileStream","slug":"проблемы-filestream","link":"#проблемы-filestream","children":[]}]},{"level":2,"title":"Приоритеты запросов ввода-вывода","slug":"приоритеты-запросов-ввода-вывода","link":"#приоритеты-запросов-ввода-вывода","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch28_IOBoundAsyncOperations.md"}');export{d as comp,k as data};
