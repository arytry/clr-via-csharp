import{_ as s,o as n,c as a,e}from"./app-IxoMmWNN.js";const t={},p=e(`<h1 id="настраиваемые-атрибуты" tabindex="-1"><a class="header-anchor" href="#настраиваемые-атрибуты"><span>Настраиваемые атрибуты</span></a></h1><p><em>Настраиваемые атрибуты</em> (custom attributes) - один из новаторских механизмов .NET Framework. Они позволяют снабжать код декларативными аннотациями, наделяя его особыми возможностями. Атрибуты дают возможность задать информацию к любой записи таблицы метаданных, а затем эту информацию можно получить в коде во время выполнения.</p><h2 id="сфера-применения-настраиваемых-атрибутов" tabindex="-1"><a class="header-anchor" href="#сфера-применения-настраиваемых-атрибутов"><span>Сфера применения настраиваемых атрибутов</span></a></h2><p>Атрибуты крайне полезны, однако иногда бывают ситуации, когда необходимо определить для типа (или его члена) дополнительную информацию, например, о возможности сериализации или необходимости в получении некоторых разрешений безопасности. Для этих целей выступают настраиваемые атрибуты.</p><p>Использовать настраиваемые атрибуты крайне удобно, однако фирмы-разработчики предпочитают не публиковать исходный код своих компиляторов, поэтому Microsoft предложила альтернативный способ работы с атрибутами. Определять и задействовать их может кто угодно, а все CLR-совместимые компиляторы умеют их распознавать и генерировать соответствующие метаданные.</p><p>Атрибуты представляют собой лишь средство передачи некоторой дополнительной информации, компилятор помещает эту информацию в метаданные, в остальном - они для него не имеют смысла.</p><p>В C# имена настраиваемых атрибутов помещаются в квадратные скобки непосредственно перед именем класса, объекта и т. п.</p><p>CLR позволяет применять атрибуты ко всему, что может быть представлено метаданными. Чаще всего они применяются к записям в следующим таблицах: <code>TypeDef</code> (любые создаваемые типы), <code>MethodDef</code> (конструкторы), <code>ParamDef</code>, <code>FieldDef</code>, <code>PropertyDef</code>, <code>EventDef</code>, <code>AssemblyDef</code>. В частности, C# позволяет применять атрибуты к коду, определяющему сборки, модули, типы, поля, методы, параметры методов, возвращаемые значения, свойства, события, параметры обобщённого типа. Можно задать префикс, указывающий явно, к чему будет применён атрибут, однако компилятор способен сделать это и сам. Обязательные префиксами являются <code>assemble</code>, <code>module</code>, <code>return</code>, <code>field</code> и <code>method</code>.</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">assembly</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к сборке</span>
<span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">module</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к модулю</span>

<span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">type</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к типу</span>
<span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType<span class="token punctuation">&lt;</span><span class="token punctuation">[</span>typevar<span class="token punctuation">:</span> SomeAttr<span class="token punctuation">]</span> T<span class="token punctuation">&gt;</span></span> <span class="token comment">// Применяется к переменной обобщенного типа</span>
<span class="token punctuation">{</span> 
  <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">field</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к полю</span>
  <span class="token keyword">public</span> <span class="token class-name">Int32</span> SomeField <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">return</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к возвращаемому значению</span>
  <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">method</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к методу</span>
  <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">param</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token class-name">Int32</span> SomeParam<span class="token punctuation">)</span> <span class="token comment">// Применяется к параметру</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> SomeParam<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">property</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к свойству</span>
  <span class="token keyword">public</span> <span class="token return-type class-name">String</span> SomeProp
  <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">method</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к механизму доступа get</span>
    <span class="token keyword">get</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">event</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к событиям</span>
  <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">field</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к полям, созданным компилятором</span>
  <span class="token punctuation">[</span><span class="token attribute"><span class="token target keyword">method</span><span class="token punctuation">:</span> <span class="token class-name">SomeAttr</span></span><span class="token punctuation">]</span> <span class="token comment">// Применяется к созданным компилятором методам add и remove</span>
  <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">EventHandler</span> SomeEvent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Настраиваемый атрибут - всего лишь экземпляр типа. Для соответствия CLS он должен явно или косвенно наследоваться от абстрактного класса <code>System.Attribute</code>. В C# допустимы только CLS-совместимые атрибуты.</p><p>При определении атрибута компилятор позволяет опускать суффикс <code>Attribute</code>, что позволяет сделать код более читаемым.</p><p>Так как атрибут является экземпляром класса, то класс должен иметь открытый конструктор. По факту, синтаксис применения атрибута аналогичен вызову конструктора. Кроме того, используемый язык может поддерживать специальный синтаксис для определения открытых полей атрибута.</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">DllImport</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">&quot;Kernel32&quot;</span><span class="token punctuation">,</span> CharSet <span class="token operator">=</span> CharSet<span class="token punctuation">.</span>Auto<span class="token punctuation">,</span> SetLastError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>В приведённом выше примере конструктор атрибута принимает один строковый параметр (<code>&quot;Kernel32&quot;</code>), такие параметры называются <em>позиционными</em> (positional parameters) и они являются обязательными. После этого через запятую можно присвоить значения открытым полям, такие параметры называются <em>именованными</em> (named parameters) и являются необязательными.</p><p>К одному элементу можно применить несколько атрибутов, порядок их следования не имеет значения. В C# отдельные атрибуты могут заключаться в квадратные скобки или идти через запятую. Кроме этого, если конструктор не имеет параметров, круглые скобки можно опустить.</p><h2 id="определение-класса-атрибутов" tabindex="-1"><a class="header-anchor" href="#определение-класса-атрибутов"><span>Определение класса атрибутов</span></a></h2><p>Атрибут следует рассматривать как логический контейнер состояния. Иначе говоря, хоть атрибут и является классом, этот класс должен быть крайне простым. Он должен содержать всего один открытый конструктор, принимающий обязательную информацию о состоянии атрибута. Также класс может содержать открытые поля или свойства, представляющие дополнительную информацию. В классе не должно быть открытых методов или других членов.</p><p>Если при определении класса атрибутов забыть применить атрибут, указывающий на область действия, то создаваемый атрибут можно будет применить к любым элементам, но только единожды. Кроме того, он будет наследуемым.</p><p>Более подробно о создании класса атрибутов можно прочитать в главе.</p><h2 id="конструктор-атрибута-и-типы-данных-полеи-и-своиств" tabindex="-1"><a class="header-anchor" href="#конструктор-атрибута-и-типы-данных-полеи-и-своиств"><span>Конструктор атрибута и типы данных полей и свойств</span></a></h2><p>Определяя конструктор экземпляров класса атрибутов стоит ограничиться примитивными типами, а также можно использовать тип <code>Type</code>. Кроме того, можно передавать SZ-массивы, хотя в таком случае атрибут не будет CLS-совместимым. Применяя атрибут, следует указать постоянное выражение. Пример:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>

<span class="token keyword">internal</span> <span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> Red <span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">AttributeUsage</span><span class="token attribute-arguments"><span class="token punctuation">(</span>AttributeTargets<span class="token punctuation">.</span>All<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
<span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeAttribute</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">Attribute</span></span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">SomeAttribute</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">Type<span class="token punctuation">[</span><span class="token punctuation">]</span></span> types<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// &#39;name&#39; ссылается на String</span>
    <span class="token comment">// &#39;o&#39; ссылается на один из легальных типов (упаковка при необходимости)</span>
    <span class="token comment">// &#39;types&#39; ссылается на одномерный массив Types с нулевой нижней границей</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Some</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">&quot;Jeff&quot;</span><span class="token punctuation">,</span> Color<span class="token punctuation">.</span>Red<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Type<span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">{</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Math</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Console</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
<span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SomeType</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Обнаружив атрибут, компилятор создаёт экземпляр класса, передавая конструктору все указанные параметры. Затем он присваивает значения открытым полям и свойствам. Инициализировав объект, компилятор сериализует его и сохраняет в таблице метаданных.</p><p>Настраиваемый атрибут лучше всего представлять, как экземпляр класса, сериализованный в байтовый поток, находящийся в метаданных. В период выполнения байты из метаданных десериализуются для создания экземпляра класса. На самом деле компилятор генерирует необходимую для создания экземпляра атрибута информацию и размещает её в метаданных. Каждый параметр конструктора записывается с однобайтным идентификатором, за которым следует его значение. Завершив сериализацию параметров, компилятор генерирует значения для каждого указанного поля и свойства, записывая его имя, за которым следует однобайтный идентификатор типа и значение. Для массивов сначала указывается количество элементов.</p><h2 id="выявление-настраиваемых-атрибутов" tabindex="-1"><a class="header-anchor" href="#выявление-настраиваемых-атрибутов"><span>Выявление настраиваемых атрибутов</span></a></h2><p>Само по себе определение атрибута бесполезно, так как это приведёт только к появлению дополнительных метаданных в сборке. Наличие атрибутов должно переопределять некоторое поведение типа. Для этого во время выполнения происходит проверка, которая с помощью <em>отражения</em> (рефлексии, reflection) выясняет наличие определённого атрибута и вызывает соответствующий код</p><p>Проверить наличие атрибута в FCL можно различными способами. Для объектов <code>System.Type</code> можно использовать метод <code>IsDefined()</code>. Однако для сборки, модуля или метода это не сработает. Для всех CLS-совместимых атрибутов базовыми являются методы класса <code>System.Reflection.CustomAttributesExtensions</code>. В нём имеется три метода, каждый из которых имеет перегруженные версии.</p><p>Если нужно установить только сам факт наличия атрибутам, используется метод <code>IsDefined()</code>, так как он самый быстрый за счёт того, что не десериализует данные.</p><p>Для создания объектов атрибутов используются методы <code>GetCustomAttributes()</code> и <code>GetCustomAttribute()</code>. Они отличаются тем, что первый позволяет находит атрибуты, для которых разрешено множественное объявление (то есть для который <code>AllowMultiple</code> равно <code>true</code>). При каждом вызове этих методов создаются экземпляры атрибутов, которые содержат в себе поля и свойства, и возвращаются ссылки на созданные объекты.</p><p>Эти методы просматривают данные управляемого модуля и сравнивают строки в поиске указанного класса атрибута. Эти операции требуют времени, так что стоит подумать о кэшировании, если волнует быстродействие.</p><p>В пространстве имён <code>System.Reflection</code> находятся классы, позволяющие анализировать содержимое метаданных модуля, а также соответствующие им билдеры. Все эти классы содержат методы <code>IsDefined()</code> и <code>GetCustomAttributes()</code>. Последний метод возвращает массив экземпляров <code>Object</code>, а не <code>Attribute</code>, так как некоторые классы атрибутов могут не соответствовать CLS. Хотя в реальности это может происходить довольно редко.</p><p>Есть ещё один аспект, связанный с данными методами. Они ищут класс атрибута и производные от него. Для поиска конкретного класса требуется дополнительная проверка. Или можно сделать класс атрибута запечатанным.</p><h2 id="сравнение-экземпляров-атрибута" tabindex="-1"><a class="header-anchor" href="#сравнение-экземпляров-атрибута"><span>Сравнение экземпляров атрибута</span></a></h2><p>Сравнение атрибутов похоже на сравнение значимых типов. Переопределённый метод <code>Equals()</code> определяет совпадают ли типы и, если типы совпадают, проверяют каждое поле через рефлексию. То есть для повышения производительности стоит также переопределить данный метод в собственных классах настраиваемых атрибутов.</p><h2 id="выявление-настраиваемых-атрибутов-без-создания-объектов-производных-от-attribute" tabindex="-1"><a class="header-anchor" href="#выявление-настраиваемых-атрибутов-без-создания-объектов-производных-от-attribute"><span>Выявление настраиваемых атрибутов без создания объектов, производных от Attribute</span></a></h2><p>При вызове методов для получения атрибутов из типа <code>Attribute</code> вызывается конструктор класса атрибута и методы, задающие значения свойств. А первое обращение к типу заставляет CLR вызвать статический конструктор (если он определён). Конструктор, методы доступа <code>set</code> и методы статического конструктора могут содержать код, выполняющийся при каждом поиске атрибута. Возможность выполнения в домене неизвестного кода создаёт потенциальную угрозу безопасности.</p><p>Для обнаружения атрибутов без выполнения кода класса используется статический метод <code>System.Reflection.CustomAttributeData.GetCustomAttribures()</code>. Отличие этого метода от ранее рассмотренных в том, что он возвращает именно информацию об атрибуте, а не создаёт экземпляр его типа и соответственно, не вызывает никаких методов.</p><h2 id="условные-атрибуты" tabindex="-1"><a class="header-anchor" href="#условные-атрибуты"><span>Условные атрибуты</span></a></h2><p>Иногда могут возникать ситуации, когда атрибут нужен не всегда. Для этого к классу создаваемого атрибута можно применить атрибут <code>System.Diagnostics.ConditionalAttribute</code>. В этом случае создаваемый класс называется <em>условным атрибутом</em> (conditional attribute). Для такого атрибута компилятор будет помещать информацию в метаданные, только если при компиляции будет определён соответствующий идентификатор.</p>`,39),c=[p];function o(l,i){return n(),a("div",null,c)}const d=s(t,[["render",o],["__file","ch18_CustomAttributes.html.vue"]]),r=JSON.parse('{"path":"/ru/chapters/ch18_CustomAttributes.html","title":"Настраиваемые атрибуты","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Сфера применения настраиваемых атрибутов","slug":"сфера-применения-настраиваемых-атрибутов","link":"#сфера-применения-настраиваемых-атрибутов","children":[]},{"level":2,"title":"Определение класса атрибутов","slug":"определение-класса-атрибутов","link":"#определение-класса-атрибутов","children":[]},{"level":2,"title":"Конструктор атрибута и типы данных полей и свойств","slug":"конструктор-атрибута-и-типы-данных-полеи-и-своиств","link":"#конструктор-атрибута-и-типы-данных-полеи-и-своиств","children":[]},{"level":2,"title":"Выявление настраиваемых атрибутов","slug":"выявление-настраиваемых-атрибутов","link":"#выявление-настраиваемых-атрибутов","children":[]},{"level":2,"title":"Сравнение экземпляров атрибута","slug":"сравнение-экземпляров-атрибута","link":"#сравнение-экземпляров-атрибута","children":[]},{"level":2,"title":"Выявление настраиваемых атрибутов без создания объектов, производных от Attribute","slug":"выявление-настраиваемых-атрибутов-без-создания-объектов-производных-от-attribute","link":"#выявление-настраиваемых-атрибутов-без-создания-объектов-производных-от-attribute","children":[]},{"level":2,"title":"Условные атрибуты","slug":"условные-атрибуты","link":"#условные-атрибуты","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch18_CustomAttributes.md"}');export{d as comp,r as data};
