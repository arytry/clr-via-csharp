<!doctype html>
<html lang="ru-RU">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <link rel="icon" href="/assets/img/favicon.ico"><title>Асинхронные вычислительные операции | CLR via C#</title><meta name="description" content="CLR via C# Четвертое издание">
    <link rel="preload" href="/clr-via-csharp/assets/style-FaCSB-_p.css" as="style"><link rel="stylesheet" href="/clr-via-csharp/assets/style-FaCSB-_p.css">
    <link rel="modulepreload" href="/clr-via-csharp/assets/app-IxoMmWNN.js"><link rel="modulepreload" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DXXfHTUn.js">
    <link rel="prefetch" href="/clr-via-csharp/assets/index.html-ZkH5qKEm.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-BvaI8qfN.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-D-7172Jl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BLQSYEbL.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-Cmb5tXx5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-C65m3L6w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-MhrBc603.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BExRN6IU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-Cwf82xZd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-U9jK40Ei.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CUDFuVYa.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-0oTJyJmn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-LLUaep7w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-Bi9j89Ya.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-Dbx7WK6o.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-DsmoFQbF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-noMBAT3f.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-MFb5H9zK.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-ZDLMr6H2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DYgFyOwD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-BtysPki2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CDUugoVg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BWeh_aT3.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-CfeNN69i.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-D16BElAb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-DK1leolo.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-CQ2ygEuE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-C3cvw10V.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-CMPdATok.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-CTieDbCf.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CJcp4OCy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-CFsstSQQ.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-beZI77Lv.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-Bi67Yt5h.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-dvExR8Gk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-GDcN_xMH.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BwKxRLwh.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-BMQPeoI2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-27zHcXlW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-CVDf2x4Y.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-DkaxxntM.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-BGwRCWdf.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-D2jgyLeB.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CcZqtO9s.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-Cgf_mCwx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-CO8XAMmW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-DZ5a5JQg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-D0mGmkov.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-BGdd7LBY.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-DExRFCv1.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BiTZ-5od.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-Dsjpqw47.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DWEP33D9.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-DtaR-VvP.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CvrkASkk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BuN-nGuz.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-f0AOnmUF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-C4pcwqj-.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-CHZCU__5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-emd0r8wc.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-BmMk3Oqy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-DDuBq2h_.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CwFR1TuA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-Bjaf8DNA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-D2MW45gx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-Bpkc--tR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BPnkWvJ8.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-q0yDwRpt.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-BjqQ7sdC.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-BIIy8leD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BOo-9fso.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-DzDrvZ87.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-CASmG777.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CEM163Qb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-BkR6SOXn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-sfPfXudR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-LJfkVvEp.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-CSXiWNpq.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-CBasocgy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-o4yS52Dy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BZtqvWYE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-CGp-_Jrw.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-tcKP_pXy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-B6RvN9hy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-BkMiV6yx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BsTwrSmr.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-BDn6rSrD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-Bi_35IQj.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-stJPEo8t.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-BexV0ImS.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-Cw_fsfmx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-QnhhtSZl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DNJcQUkI.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-BAwtWkjU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-5-bQNQmT.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-DKmbpj4c.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-GASyXvmd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-D6bO62ut.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/404.html-5gOqppNC.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/clr-via-csharp/ru/"><img class="logo" src="/clr-via-csharp/assets/images/cover.jpg" alt="CLR via C#"><span class="site-name can-hide" aria-hidden="true">CLR via C#</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/chapters/ch27_ComputeBoundAsync.html" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/chapters/ch27_ComputeBoundAsync.html" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch01_TheCLRSExecutionMode.html" aria-label="Модель выполнения кода в среде CLR"><!--[--><!--[--><!--]--> Модель выполнения кода в среде CLR <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch02_Building.html" aria-label="Компоновка, упаковка, развёртывание и администрирование приложений и типов"><!--[--><!--[--><!--]--> Компоновка, упаковка, развёртывание и администрирование приложений и типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch03_SharedAssemblies.html" aria-label="Совместно используемые сборки и сборки со строгим именем"><!--[--><!--[--><!--]--> Совместно используемые сборки и сборки со строгим именем <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch04_TypeFundamentals.html" aria-label="Основы типов"><!--[--><!--[--><!--]--> Основы типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch05_PrimitiveRefValType.html" aria-label="Примитивные, ссылочные и значимые типы"><!--[--><!--[--><!--]--> Примитивные, ссылочные и значимые типы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch06_TypeAndMemberBasics.html" aria-label="Основные сведения о членах и типах"><!--[--><!--[--><!--]--> Основные сведения о членах и типах <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch07_ConstantsAndFields.html" aria-label="Константы и поля"><!--[--><!--[--><!--]--> Константы и поля <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch08_Methods.html" aria-label="Методы"><!--[--><!--[--><!--]--> Методы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch09_Parameters.html" aria-label="Параметры"><!--[--><!--[--><!--]--> Параметры <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch10_Properties.html" aria-label="Свойства"><!--[--><!--[--><!--]--> Свойства <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch11_Events.html" aria-label="События"><!--[--><!--[--><!--]--> События <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch12_Generics.html" aria-label="Обобщения"><!--[--><!--[--><!--]--> Обобщения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch13_Interfaces.html" aria-label="Интерфейсы"><!--[--><!--[--><!--]--> Интерфейсы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch14_CharStringText.html" aria-label="Символы, строки и обработка текста"><!--[--><!--[--><!--]--> Символы, строки и обработка текста <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch15_EnumeratedTypes.html" aria-label="Перечислимые типы и битовые флаги"><!--[--><!--[--><!--]--> Перечислимые типы и битовые флаги <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch16_Arrays.html" aria-label="Массивы"><!--[--><!--[--><!--]--> Массивы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch17_Delegates.html" aria-label="Делегаты"><!--[--><!--[--><!--]--> Делегаты <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch18_CustomAttributes.html" aria-label="Настраиваемые атрибуты"><!--[--><!--[--><!--]--> Настраиваемые атрибуты <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch19_NullableValueTypes.html" aria-label="Null-совместимые значимые типы"><!--[--><!--[--><!--]--> Null-совместимые значимые типы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch20_ExceptionsAndStateManae.html" aria-label="Исключения и управление состоянием"><!--[--><!--[--><!--]--> Исключения и управление состоянием <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch21_ManagedHeapGarbage.html" aria-label="Автоматическое управление памятью (сборка мусора)"><!--[--><!--[--><!--]--> Автоматическое управление памятью (сборка мусора) <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch22_CLRHostingAndAppDomain.html" aria-label="Хостинг CLR и домены приложений"><!--[--><!--[--><!--]--> Хостинг CLR и домены приложений <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch23_AssemblyLoaingReflection.html" aria-label="Загрузка сборок и отражение"><!--[--><!--[--><!--]--> Загрузка сборок и отражение <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch24_RuntimeSerialization.html" aria-label="Сериализация"><!--[--><!--[--><!--]--> Сериализация <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch25_WinRTComponents.html" aria-label="Взаимодействие с компонентами WinRT"><!--[--><!--[--><!--]--> Взаимодействие с компонентами WinRT <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch26_ThreadBasics.html" aria-label="Потоки исполнения"><!--[--><!--[--><!--]--> Потоки исполнения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active sidebar-item sidebar-heading active" href="/clr-via-csharp/ru/chapters/ch27_ComputeBoundAsync.html" aria-label="Асинхронные вычислительные операции"><!--[--><!--[--><!--]--> Асинхронные вычислительные операции <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#пул-потоков-в-clr" aria-label="Пул потоков в CLR"><!--[--><!--[--><!--]--> Пул потоков в CLR <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#простые-вычислительные-операции" aria-label="Простые вычислительные операции"><!--[--><!--[--><!--]--> Простые вычислительные операции <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#контексты-исполнения" aria-label="Контексты исполнения"><!--[--><!--[--><!--]--> Контексты исполнения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#скоординированная-отмена" aria-label="Скоординированная отмена"><!--[--><!--[--><!--]--> Скоординированная отмена <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#задания" aria-label="Задания"><!--[--><!--[--><!--]--> Задания <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#завершение-задания-и-получение-результата" aria-label="Завершение задания и получение результата"><!--[--><!--[--><!--]--> Завершение задания и получение результата <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#отмена-задания" aria-label="Отмена задания"><!--[--><!--[--><!--]--> Отмена задания <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#автоматическии-запуск-задания-по-завершении-предыдущего" aria-label="Автоматический запуск задания по завершении предыдущего"><!--[--><!--[--><!--]--> Автоматический запуск задания по завершении предыдущего <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#дочерние-задания" aria-label="Дочерние задания"><!--[--><!--[--><!--]--> Дочерние задания <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#структура-задания" aria-label="Структура задания"><!--[--><!--[--><!--]--> Структура задания <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#фабрики-задании" aria-label="Фабрики заданий"><!--[--><!--[--><!--]--> Фабрики заданий <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#планировщики-задании" aria-label="Планировщики заданий"><!--[--><!--[--><!--]--> Планировщики заданий <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#методы-for-foreach-и-invoke-класса-parallel" aria-label="Методы For, ForEach и Invoke класса Parallel"><!--[--><!--[--><!--]--> Методы For, ForEach и Invoke класса Parallel <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#встроенныи-язык-параллельных-запросов" aria-label="Встроенный язык параллельных запросов"><!--[--><!--[--><!--]--> Встроенный язык параллельных запросов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#периодические-вычислительные-операции" aria-label="Периодические вычислительные операции"><!--[--><!--[--><!--]--> Периодические вычислительные операции <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#разновидности-таимеров" aria-label="Разновидности таймеров"><!--[--><!--[--><!--]--> Разновидности таймеров <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#как-пул-управляет-потоками" aria-label="Как пул управляет потоками"><!--[--><!--[--><!--]--> Как пул управляет потоками <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#ограничение-количества-потоков-в-пуле" aria-label="Ограничение количества потоков в пуле"><!--[--><!--[--><!--]--> Ограничение количества потоков в пуле <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#управление-рабочими-потоками" aria-label="Управление рабочими потоками"><!--[--><!--[--><!--]--> Управление рабочими потоками <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch28_IOBoundAsyncOperations.html" aria-label="Асинхронные операции ввода-вывода"><!--[--><!--[--><!--]--> Асинхронные операции ввода-вывода <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch29_PrimitiveThreadSyncConstructs.html" aria-label="Примитивные конструкции синхронизации потоков"><!--[--><!--[--><!--]--> Примитивные конструкции синхронизации потоков <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch30_hybridThreadSyncConst.html" aria-label="Гибридные конструкции синхронизации потоков"><!--[--><!--[--><!--]--> Гибридные конструкции синхронизации потоков <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="асинхронные-вычислительные-операции" tabindex="-1"><a class="header-anchor" href="#асинхронные-вычислительные-операции"><span>Асинхронные вычислительные операции</span></a></h1><h2 id="пул-потоков-в-clr" tabindex="-1"><a class="header-anchor" href="#пул-потоков-в-clr"><span>Пул потоков в CLR</span></a></h2><p>CLR способна управлять собственным пулом потоков, то есть набором готовых потоков, доступных для использования приложениями. Для каждого экземпляра CLR существует свой пул, используемый всеми доменами.</p><p>При инициализации CLR пул потоков пуст. Для выполнения приложением асинхронной операции вызывается метод, размещающий соответствующий запрос в очереди пула потоков. Код пула извлекает записи из очереди и распределяет и среди потоков пула. Если пул пуст, создаётся новый поток. По завершении задания поток не уничтожается, а возвращается в пул. Благодаря этому производительность не страдает.</p><p>Когда приложение отправляет пулу много запросов, он пытается обслужить их все в одном потоке. Однако если приложение создаёт очередь запросов быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки. Такой подход позволяет обойтись небольшим числом потоков.</p><p>Когда приложение прекращает отправлять запросы в пул, появляются незанятые потоки. Через некоторое время бездействия поток пробуждается и уничтожается, освобождая ресурсы.</p><p>Пул потоков позволяет найти компромисс в ситуации, когда малое количество потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами многопроцессорных систем, а также многоядерных и гиперпотоковых процессоров.</p><h2 id="простые-вычислительные-операции" tabindex="-1"><a class="header-anchor" href="#простые-вычислительные-операции"><span>Простые вычислительные операции</span></a></h2><p>В разделе описывается добавление асинхронных вычислительных операций в очередь пула потоков с помощью метода <code>ThreadPool.QueueUserWorkItem()</code>.</p><h2 id="контексты-исполнения" tabindex="-1"><a class="header-anchor" href="#контексты-исполнения"><span>Контексты исполнения</span></a></h2><p>С каждым потоком связан определённый контекст исполнения, который включает в себя параметры безопасности, параметры хоста и контекстные данные логического вызова.</p><p>По умолчанию CLR автоматически копирует контекст исполнения самого первого потока во все вспомогательные потоки. Это гарантирует безопасность, но в ущерб производительности. С помощью класса <code>System.Threading.ExecutionContext</code> можно запретить копирование контекста, что может сильно повысить быстродействие серверных приложений.</p><h2 id="скоординированная-отмена" tabindex="-1"><a class="header-anchor" href="#скоординированная-отмена"><span>Скоординированная отмена</span></a></h2><p>.NET предлагает стандартный паттерн операций отмены. Этот паттерн является <em>скоординированным</em> (cooperative), то есть требует явной поддержки отмены операций. В состав стандартного паттерна скоординированной отмены входят два типа из FCL: <code>CancellationTokenSource</code> (ссылочный тип) и <code>CancellationToken</code> (значимый тип). После создания <code>CancellationTokenSource</code> можно получить один или несколько экземпляров <code>CancellationToken</code>. Затем они передаются операциям, поддерживающим отмену.</p><p>Экземпляр <code>CancellationToken</code> относится к упрощённому типу, так как содержит одно закрытое поле: ссылку на свой объект <code>CancellationTokenSource</code>. Цикл вычислительной операции может периодически обращаться к свойству <code>CancellationToken.IsCancellationRequested</code>, чтобы узнать, не требуется ли прерывание операции. Тогда процессор перестаёт совершать операции.</p><h2 id="задания" tabindex="-1"><a class="header-anchor" href="#задания"><span>Задания</span></a></h2><p>Самой большой проблемой при вызове метода <code>ThreadPool.QueueUserWorkItem()</code> является отсутствие временного механизма, позволяющего узнать о завершении операции и получить возвращаемое значение. Для обхода этих и других ограничений было введено понятие <em>заданий</em> (tasks), выполнение которых выполняется посредством типов из пространства имён <code>System.Threading.Tasks</code>.</p><h3 id="завершение-задания-и-получение-результата" tabindex="-1"><a class="header-anchor" href="#завершение-задания-и-получение-результата"><span>Завершение задания и получение результата</span></a></h3><p>Можно дождаться завершения задания в явном виде с помощью экземплярного метода <code>Task.Wait()</code> и после этого получить результат его выполнения. Для этого можно создать объект типа <code>Task&lt;TResult&gt;</code>, передав в качестве аргумента-типа возвращаемый задачей тип.</p><p>При вызове потоком метода <code>Wait()</code>, система проверяет, началось ли выполнение задания, которого ожидает поток. Если да, то поток блокируется до завершения задачи. Но если выполнение ещё не началось, то система может выполнить его при помощи потока, вызывающего метод <code>Wait()</code>. В этом случае поток не блокируется. Он выполняет задание и возвращает управление. Это снижает затраты, так как не приходится создавать поток взамен заблокированного, и повышает производительность, так как на создание потока и переключение контекста не тратится время. Однако если перед вызовом <code>Wait()</code> поток блокируется в рамках синхронизации, то возникает взаимная блокировка (deadlock).</p><p>Если задание генерирует исключение, то оно поглощается и сохраняется в коллекции, а поток возвращается в пул. Затем при вызове метода <code>Wait()</code> или свойства <code>Result</code> эти члены выбросят исключение <a href="https://learn.microsoft.com/en-us/dotnet/api/system.aggregateexception?view=net-8.0" target="_blank" rel="noopener noreferrer">AggregateException<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>.</p><p>Можно дожидаться завершения не только одного задания, но и массива объектов этого типа. Для этого есть два статических метода <code>WaitAny()</code> и <code>WaitAll()</code>.</p><h3 id="отмена-задания" tabindex="-1"><a class="header-anchor" href="#отмена-задания"><span>Отмена задания</span></a></h3><p>Для отмены задания можно воспользоваться объектом <code>CancellationTokenSource</code>, для этого в метод необходимо добавить генерацию исключения, если задача отменена. Исключение генерируется как сигнал того, завершена ли задача.</p><h3 id="автоматическии-запуск-задания-по-завершении-предыдущего" tabindex="-1"><a class="header-anchor" href="#автоматическии-запуск-задания-по-завершении-предыдущего"><span>Автоматический запуск задания по завершении предыдущего</span></a></h3><p>Для написания масштабируемого ПО стоит избегать блокировки потоков. Вызов метода <code>Wait()</code> или свойства <code>Result</code> при незавершённом задании приведёт, скорее всего, к появлению в пуле нового потока, то увеличит расход ресурсов и негативно скажется на расширяемости. Для того, чтобы избежать блокирования потоков, стоит инициировать следующее задание по выполнению предыдущего с помощью методы <code>ContinueWith()</code>. Исполняющий такой код поток не блокируется, ожидая завершения заданий; в это время он может исполнять какой-то другой код или, если это поток из пула, вернуться в пул для решения других задач.</p><h3 id="дочерние-задания" tabindex="-1"><a class="header-anchor" href="#дочерние-задания"><span>Дочерние задания</span></a></h3><p>Задания поддерживают отношения предок-потомок. Родительское задание выполняется после того, как будут завершены все дочерние задания.</p><h3 id="структура-задания" tabindex="-1"><a class="header-anchor" href="#структура-задания"><span>Структура задания</span></a></h3><p>Тип <a href="https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.tasks.task?view=net-8.0" target="_blank" rel="noopener noreferrer"><code>Task</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> обладает набором членов, которые отнимают дополнительные ресурсы. Если эти поля не нужны, то рекомендуется воспользоваться методом <code>ThreadPool.QueueUserWorkItem()</code>.</p><h3 id="фабрики-задании" tabindex="-1"><a class="header-anchor" href="#фабрики-задании"><span>Фабрики заданий</span></a></h3><p><em>Фабрики заданий</em> (task factory) используются в ситуациях, когда необходимо создать несколько заданий, находящихся в одном и том же состоянии.</p><h3 id="планировщики-задании" tabindex="-1"><a class="header-anchor" href="#планировщики-задании"><span>Планировщики заданий</span></a></h3><p>Объект <code>TaskScheduler</code> отвечает за выполнение запланированных заданий и выводит информацию о них в отладчике. В FCL существует два производных от данного типа: планировщик заданий в пуле потоков и планировщик заданий контекста синхронизации. По умолчанию все приложения используют первый. Второй тип планировщика используется обычно в приложениях с графическим интерфейсом.</p><h2 id="методы-for-foreach-и-invoke-класса-parallel" tabindex="-1"><a class="header-anchor" href="#методы-for-foreach-и-invoke-класса-parallel"><span>Методы For, ForEach и Invoke класса Parallel</span></a></h2><p>Существуют ситуации, в которых возможно повышение производительности, обусловленное применением заданий. Для упрощения программирования эти сценарии инкапсулированы в статический класс <code>System.Threading.Tasks.Parallel</code>, предназначенный для распределения работы между несколькими потоками из пула.</p><p>Все методы данного класса заставляют вызывающи поток принимать участие в их обработке. При этом вызывающий поток не блокируется, ожидая выполнения работы потоками пула. Однако если выполнение вызывающего потока будет закончено до выполнения своей части потомки из пула, он будет приостановлен до их завершения.</p><p>Любое применение данного класса разумно только для заданий, которые <em>могут</em> выполняться параллельно, а также следует избегать рабочих элементов, вносящих изменения в любые совместно используемые данные, так как при управлении несколькими потоками эти данные могут быть повреждены. Кроме того, методы данного класса потребляют много ресурсов - приходится выделять память под делегаты, которые вызываются по одному для каждого рабочего элемента. Это значит, сто распараллеливание не резонно для небольшого числа элементов или элементов, обслуживание которых происходит очень быстро.</p><h2 id="встроенныи-язык-параллельных-запросов" tabindex="-1"><a class="header-anchor" href="#встроенныи-язык-параллельных-запросов"><span>Встроенный язык параллельных запросов</span></a></h2><p>LINQ предлагает удобный синтаксис запросов к данным, при этом все элементы в наборе данных обрабатываются последовательно одним потоком - это называется <em>последовательным запросом</em> (sequential query). Повысить производительность можно при помощи языка параллельных запросов (Parallel LINQ), позволяющего последовательный запрос превратить в <em>параллельный</em> (parallel query). Последний во внутренней реализации задействует задания (поставленные в очередь планировщиком, используемым по умолчанию), распределяя элементы коллекции среди нескольких процессоров. Выигрыш в производительности происходит в случаях, аналогичных использованию <code>Parallel</code>.</p><h2 id="периодические-вычислительные-операции" tabindex="-1"><a class="header-anchor" href="#периодические-вычислительные-операции"><span>Периодические вычислительные операции</span></a></h2><p>Для выполнения периодических операций в пространстве имён <code>System.Threading</code> определён класс <code>Timer</code>. Данный класс периодически вызывает методы обратного вызова с помощью потоков из пула.</p><p>Кроме того, для периодического выполнения операций возможен другой вариант - с использованием статического метода <code>Delay()</code> класса <code>Task</code> в сочетании с ключевыми словами <code>async</code> и <code>await</code>.</p><h3 id="разновидности-таимеров" tabindex="-1"><a class="header-anchor" href="#разновидности-таимеров"><span>Разновидности таймеров</span></a></h3><p>FCL содержит различные таймеры:</p><ul><li><code>System.Threading.Timer</code> - лучше других подходит для выполнения повторяющихся заданий с потоками пула.</li><li><code>System.Windows.Forms.Timer</code> - вся работа осуществляется одним потоком, что предотвращает параллельное выполнение метода таймера в нескольких потоках.</li><li><code>System.Windows.Threading.DispatcherTimer</code> - является эквивалентом <code>System.Windows.Forms.Timer</code> но для приложений Silverlight и WPF.</li><li><code>Windows.UI.XAML.DispatcherTimer</code> - является эквивалентом <code>System.Windows.Forms.Timer</code> но для приложений Windows Store.</li><li><code>System.Timers.Timer</code> - заставляет CLR по срабатыванию таймера ставить события в очередь пула потоков.</li></ul><h2 id="как-пул-управляет-потоками" tabindex="-1"><a class="header-anchor" href="#как-пул-управляет-потоками"><span>Как пул управляет потоками</span></a></h2><h3 id="ограничение-количества-потоков-в-пуле" tabindex="-1"><a class="header-anchor" href="#ограничение-количества-потоков-в-пуле"><span>Ограничение количества потоков в пуле</span></a></h3><p>Из-за проблем, связанных с зависаниями и взаимными блокировками разработчики CLR постоянно увеличивают заданное по умолчанию максимальное число потоков в пуле. 64-разрядный процесс предлагает 8 Тб адресного пространства, так что теоретически можно создать сотни тысяч потоков, но это будет пустой тратой ресурсов.</p><p>Попытки менять заданные по умолчанию ограничения пула потоков обычно ухудшают работу приложений.</p><h3 id="управление-рабочими-потоками" tabindex="-1"><a class="header-anchor" href="#управление-рабочими-потоками"><span>Управление рабочими потоками</span></a></h3><p><img src="https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/9729be7e-3149-476e-85f7-2b20c9d9898f" alt="image"></p><p>На рисунке изображены различные структуры данных, делающие рабочие потоки частью пула. Метод <code>ThreadPool.QueueUserWorkItem()</code> и класс <code>Timer</code> всегда помещают рабочие элементы в глобальную очередь. Рабочие потоки берут элементы из очереди по алгоритму FIFO. А так как при наличии нескольких потоков элементы из глобальной очереди могут удаляться одновременно. все рабочие потоки конкурируют за право на блокировку в рамках синхронизации потоков, которое гарантирует, что никакие два или более потока не смогут одновременно обрабатывать один и тот же элемент.</p><p>При планировании задания для нерабочего потока объект <code>Task</code> помещается в глобальную очередь. При этом каждый поток работает с локальной очередью, в которую и добавляется планируемые задания.</p><p>Рабочий поток, готовый к обработке элементов, сначала проверяет наличие заданий в локальной очереди. Обнаружив такой объект, он изымает его и обрабатывает. Изъятие производится по алгоритму LIFO. Так как доступ к началу локальной очереди имеет только рабочий поток, блокировка в рамках синхронизации потоков больше не требуется, а добавление заданий в очередь и их изъятие происходит очень быстро. Побочным эффектом такого поведения является то, что задания выполняются в порядке, обратном порядку их постановки в очередь.</p><p>Пул потоков не гарантирует определённого порядка обработки элементов.</p><p>Обнаружив пустую локальную очередь, рабочий поток пытается взять задание из локальной очереди другого рабочего потока. Задания берутся с конца очереди, а значит, требуется блокировка, что несколько снижает производительность. Если пустыми оказываются все локальные очереди, рабочий поток извлекает (прибегая к блокировке) элемент из глобальной очереди по алгоритму FIFO. В случае пустой глобальной очереди поток переходит в режим ожидания. Если этот режим длится долго, поток просыпается и самоуничтожается, освобождая занятые ресурсы (ядро, стеки и TEB).</p><p>По умолчанию количество создаваемых в начале потоков равно числу процессоров, которые можете задействовать процесс. Обычно процессу разрешается использовать все процессоры, и пул создаёт рабочие потоки, количество которых быстро достигает числа процессоров. Затем пул начинает отслеживать частоту завершения рабочих элементов, и для тех, выполнение которых занимает много времени, создаёт дополнительные потоки. При увеличении темпа завершения элементов рабочие потоки уничтожаются.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="external-link label" href="https://github.com/arytry/clr-via-csharp/edit/main/docs/ru/chapters/ch27_ComputeBoundAsync.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--[--><svg class="icon" viewBox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link prev" href="/clr-via-csharp/ru/chapters/ch26_ThreadBasics.html" aria-label="Потоки исполнения"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span>Потоки исполнения</span></div><!--]--></a><a class="route-link next" href="/clr-via-csharp/ru/chapters/ch28_IOBoundAsyncOperations.html" aria-label="Асинхронные операции ввода-вывода"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>Асинхронные операции ввода-вывода</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/clr-via-csharp/assets/app-IxoMmWNN.js" defer></script>
  </body>
</html>
