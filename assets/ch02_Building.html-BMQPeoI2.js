import{_ as e,o as a,c as l,e as s}from"./app-IxoMmWNN.js";const n={},i=s(`<h1 id="компоновка-упаковка-развертывание-и-администрирование-приложении-и-типов" tabindex="-1"><a class="header-anchor" href="#компоновка-упаковка-развертывание-и-администрирование-приложении-и-типов"><span>Компоновка, упаковка, развёртывание и администрирование приложений и типов</span></a></h1><h2 id="задачи-развертывания-в-net-framework" tabindex="-1"><a class="header-anchor" href="#задачи-развертывания-в-net-framework"><span>Задачи развёртывания в .NET Framework</span></a></h2><p>.NET Framework в значительной степени решает &quot;кошмар DLL&quot; (ситуация, когда установка новой программы может повлиять на работоспособность уже установленных) и делает шаг к решению проблемы с распределением данных по всей системе. Совершенствование системы защиты связано с новой моделью безопасности - <em>безопасностью доступа на уровне кода</em> (основана на правах, которые контролируются хостом приложения).</p><h2 id="компоновка-типов-в-модуль" tabindex="-1"><a class="header-anchor" href="#компоновка-типов-в-модуль"><span>Компоновка типов в модуль</span></a></h2><p>Есть простая программа:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Её можно скомпилировать командой <code>csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs</code>. Здесь:</p><ul><li>csc.exe - C Sharp Compiler</li><li>/out:Program.exe - имя создаваемого файла</li><li>/t[arget].exe - тип создаваемого файла (в данном случае консольное приложение Win32, также можно использовать /t:winexe для GUI или /t:appcontainerexe для Windows Store)</li><li>/r[eference]:MSCorLib.dll - сборка для поиска внешних типов</li></ul><p>По факту имена исполняемого файла и кода совпадают, можно опустить параметр /t. Как и параметр /r, так как библиотека MSCorLib.dll подгружается автоматически. В итоге получается стандартный PE32.</p><h3 id="фаил-параметров" tabindex="-1"><a class="header-anchor" href="#фаил-параметров"><span>Файл параметров</span></a></h3><p>Файл параметров (CSC.rsp по умолчанию или другое имя файла, определённого рядом с проектом) используется для вынесения общих параметров компилятора. Таких, например, как ссылки на все стандартные библиотеки. При компиляции конфиги в командной строке переопределяют локальные конфиги (в текущем каталоге), а локальные - глобальные (рядом с CSC.exe).</p><h2 id="несколько-слов-о-метаданных" tabindex="-1"><a class="header-anchor" href="#несколько-слов-о-метаданных"><span>Несколько слов о метаданных</span></a></h2><p>Управляемый PE-файл состоит из 4 блоков:</p><ul><li>Заголовок PE32(+) - стандартная информация, ожидаемая Windows.</li><li>Заголовок CLR - небольшой блок информации, специфичной для модулей, требующих CLR (старший и младший номера версии CLR, ряд флагов, маркер MethodDef, указывающий на точку входа, размер и смещение некоторых таблиц метаданных).</li><li>Метаданные - блок двоичных данных из нескольких таблиц (определений, ссылок и манифестов).</li><li>IL-код</li></ul><p>Основные таблицы определений:</p><ul><li>ModuleDef - Одна запись, идентифицирующая модуль (имя файла модуля с расширением и идентификатор версии в виде GUID).</li><li>TypeDef - По одной записи для каждого типа в модуле (имя типа, базовый тип, флаги сборки и указатели на другие таблицы, описывающие члены типа).</li><li>MethodDef - По одной записи для каждого метода в модуле (имя метода, флаги, сигнатуру и смещение в модуле, по которому находится IL-код, а также указатели на ParamDef, где хранятся данные о параметрах метода).</li><li>FieldDef - По одной записи для каждого поля в модуле (тип поля и флаги).</li><li>ParamDef - По одной записи для каждого параметра в модуле (тип, имя и флаги).</li><li>PropertyDef - По одной записи для каждого свойства (имя, флаги, тип и вспомогательное поле, которое может быть пустым).</li><li>EventDef - По одной записи для каждого события (имя и флаги).</li></ul><p>Основные таблицы ссылок:</p><ul><li>AssemblyRef - По одной записи для каждой сборки, на которую ссылается модуль (имя, номер версии, региональные стандарты и маркер открытого ключа).</li><li>ModuleRef - По одной записи для каждого PE-модуля, реализующего типы, на которые он ссылается (имя файла сборки и расширение).</li><li>TypeRef - По одной записи для каждого типа, на который ссылается модуль (имя типы и ссылку: TypeRef, ModuleDef, ModuleRef или AssemblyRef).</li><li>MemberRef - По одной записи для каждого члена типа, на который ссылается модуль (имя и сигнатуру члена, указатель на TypeRef).</li></ul><h2 id="объединение-модулеи-для-создания-сборки" tabindex="-1"><a class="header-anchor" href="#объединение-модулеи-для-создания-сборки"><span>Объединение модулей для создания сборки</span></a></h2><p>Получившийся Program.exe - это не просто PE-файл с метаданными, но ещё и сборка, то есть совокупность нескольких (в данном случае одного) файлов с определениями типов и файлов ресурсов. Один из файлов выбирается для хранения манифеста - набора таблиц метаданных, которые содержат имена файлов, составляющих сборку, а также версию, региональные стандарты сборки, её издателя и так далее.</p><p>CLR работает со сборками, соответственно, сначала загружается манифест, а затем остальные файлы. Некоторые характеристики сборки:</p><ul><li>В сборке определены многократно используемые типы.</li><li>Сборке назначается номер версии.</li><li>Со сборкой может быть связана информация безопасности.</li></ul><p>Чтобы упаковать типы, а также обеспечить их безопасность и управление версиями, нужно поместить типы в модули, объединённые в сборку.</p><p>Сборка позволяет разграничить логическое и физически понятие многократно используемых типов. При этом применяемые чаще типы можно поместить в один файл, а применяемые реже - в другой.</p><p>При попытке загрузить файл сборки CLR получает URL и проверяет наличие в локальном кэше. Если файл есть, то он загружается, если нет - CLR использует для загрузки URL. Если файл не найден, то генерируется исключение FileNotFoundException.</p><p>Сборка - единица многократного использования, управления версиями и безопасности типов. Загрузив файл с манифестом, CLR может определить, какие файлы сборки содержат типы и ресурсы, на которые ссылается приложение. Таким образом можно абстрагироваться от особенностей распределения содержимого сборки по файлам. При работе с многими типами, совместно использующими одну версию и набор параметров безопасности, по соображениям производительности рекомендуется размещать все типы в одном файле.</p><p>Для компоновки сборки нужно выбрать один PE-файл, который будет хранителем манифеста. Или это может быть отдельный PE-файл, который не содержит ничего, кроме манифеста. Таблицы метаданных манифеста, которые превращают управляемый модуль в сборку:</p><ul><li>AssemblyDef - Единственная запись, если модуль идентифицирует сборку (имя сборки без расширения и пути, сведения о версии, региональные стандарты, флаги, алгоритм хеширования и открытый ключ издателя).</li><li>FileDef - По одной записи для каждого PE-файла и файла ресурсов, кроме файла манифеста (имя и расширение без пути, хеш-код и флаги).</li><li>ManifestResourceDef - по одной записи для каждого ресурса (имя ресурса, флаги, индекс для FileDef).</li><li>ExportedTypesDef - Записи для всех открытых типов, экспортируемых всеми PE-модулями (имя типа, индекс для FileDef, индекс для TypeDef).</li></ul><p>Файл сборки, содержащий манифест, содержит таблицу AssemblyRef, где хранятся записи с описанием всех сборок, на которые ссылаются файлы. Это делает сборку самоописываемой.</p><p>Если компилятор генерирует исполняемый файл, то это создаёт PE-файл с таблицами метаданных манифеста. Можно также создать PE-файл без манифеста - получится DLL в формате PE. В Visual Studio отсутствует поддержка создания многофайловых сборок.</p><h3 id="добавление-сборок-в-проект-в-среде-visual-studio" tabindex="-1"><a class="header-anchor" href="#добавление-сборок-в-проект-в-среде-visual-studio"><span>Добавление сборок в проект в среде Visual Studio</span></a></h3><p><img src="https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/e781c3fc-8ce6-4400-a25c-b69355c50ece" alt="image"></p><h3 id="использование-утилиты-assembly-linker" tabindex="-1"><a class="header-anchor" href="#использование-утилиты-assembly-linker"><span>Использование утилиты Assembly Linker</span></a></h3><p>Вместо компилятора можно использовать компоновщик сборок (assembly linker, AL.exe). Компоновщик генерирует сборку только из манифеста, без IL-кода.</p><h3 id="включение-в-сборку-фаилов-ресурсов" tabindex="-1"><a class="header-anchor" href="#включение-в-сборку-фаилов-ресурсов"><span>Включение в сборку файлов ресурсов</span></a></h3><p>...</p><h2 id="ресурсы-со-сведениями-о-версии-сборки" tabindex="-1"><a class="header-anchor" href="#ресурсы-со-сведениями-о-версии-сборки"><span>Ресурсы со сведениями о версии сборки</span></a></h2><p>При компоновке через компилятор сведения о сборке задаются через атрибуты в коде, а при assembly linker&#39;ом - через параметры командной строки.</p><h3 id="номера-версии" tabindex="-1"><a class="header-anchor" href="#номера-версии"><span>Номера версии</span></a></h3><p>...</p><h2 id="региональные-стандарты" tabindex="-1"><a class="header-anchor" href="#региональные-стандарты"><span>Региональные стандарты</span></a></h2><p>Сборку без регионального стандарта называют сборкой с <em>нейтральными региональными стандартами</em>. Ресурсные файлы специфичные для региональных стандартов стоит выделять в отдельны сборки, которые называются <em>сопутствующими</em>.</p><h2 id="развертывание-простых-приложении-закрытое-развертывание-сборок" tabindex="-1"><a class="header-anchor" href="#развертывание-простых-приложении-закрытое-развертывание-сборок"><span>Развёртывание простых приложений (закрытое развёртывание сборок)</span></a></h2><p><em>Сборки с закрытым развёртыванием</em> - сборки, которые разворачиваются в том же каталоге, что и приложение.</p><h2 id="простое-средство-администрирования-конфигурационныи-фаил" tabindex="-1"><a class="header-anchor" href="#простое-средство-администрирования-конфигурационныи-фаил"><span>Простое средство администрирования (конфигурационный файл)</span></a></h2><p>Идея в том, что рядом с приложением есть конфигурационный файл, с помощью которого приложение может управлять своим каталогом и его подкаталогами, но не может управлять другими каталогами.</p><h3 id="алгоритм-поиска-фаилов-сборки" tabindex="-1"><a class="header-anchor" href="#алгоритм-поиска-фаилов-сборки"><span>Алгоритм поиска файлов сборки</span></a></h3><p>...</p>`,48),t=[i];function p(r,c){return a(),l("div",null,t)}const o=e(n,[["render",p],["__file","ch02_Building.html.vue"]]),h=JSON.parse('{"path":"/ru/chapters/ch02_Building.html","title":"Компоновка, упаковка, развёртывание и администрирование приложений и типов","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Задачи развёртывания в .NET Framework","slug":"задачи-развертывания-в-net-framework","link":"#задачи-развертывания-в-net-framework","children":[]},{"level":2,"title":"Компоновка типов в модуль","slug":"компоновка-типов-в-модуль","link":"#компоновка-типов-в-модуль","children":[{"level":3,"title":"Файл параметров","slug":"фаил-параметров","link":"#фаил-параметров","children":[]}]},{"level":2,"title":"Несколько слов о метаданных","slug":"несколько-слов-о-метаданных","link":"#несколько-слов-о-метаданных","children":[]},{"level":2,"title":"Объединение модулей для создания сборки","slug":"объединение-модулеи-для-создания-сборки","link":"#объединение-модулеи-для-создания-сборки","children":[{"level":3,"title":"Добавление сборок в проект в среде Visual Studio","slug":"добавление-сборок-в-проект-в-среде-visual-studio","link":"#добавление-сборок-в-проект-в-среде-visual-studio","children":[]},{"level":3,"title":"Использование утилиты Assembly Linker","slug":"использование-утилиты-assembly-linker","link":"#использование-утилиты-assembly-linker","children":[]},{"level":3,"title":"Включение в сборку файлов ресурсов","slug":"включение-в-сборку-фаилов-ресурсов","link":"#включение-в-сборку-фаилов-ресурсов","children":[]}]},{"level":2,"title":"Ресурсы со сведениями о версии сборки","slug":"ресурсы-со-сведениями-о-версии-сборки","link":"#ресурсы-со-сведениями-о-версии-сборки","children":[{"level":3,"title":"Номера версии","slug":"номера-версии","link":"#номера-версии","children":[]}]},{"level":2,"title":"Региональные стандарты","slug":"региональные-стандарты","link":"#региональные-стандарты","children":[]},{"level":2,"title":"Развёртывание простых приложений (закрытое развёртывание сборок)","slug":"развертывание-простых-приложении-закрытое-развертывание-сборок","link":"#развертывание-простых-приложении-закрытое-развертывание-сборок","children":[]},{"level":2,"title":"Простое средство администрирования (конфигурационный файл)","slug":"простое-средство-администрирования-конфигурационныи-фаил","link":"#простое-средство-администрирования-конфигурационныи-фаил","children":[{"level":3,"title":"Алгоритм поиска файлов сборки","slug":"алгоритм-поиска-фаилов-сборки","link":"#алгоритм-поиска-фаилов-сборки","children":[]}]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch02_Building.md"}');export{o as comp,h as data};
