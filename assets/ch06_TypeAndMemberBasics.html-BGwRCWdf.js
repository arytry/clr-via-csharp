import{_ as t,o as e,c as n,e as a}from"./app-IxoMmWNN.js";const s={},l=a(`<h1 id="основные-сведения-о-членах-и-типах" tabindex="-1"><a class="header-anchor" href="#основные-сведения-о-членах-и-типах"><span>Основные сведения о членах и типах</span></a></h1><h2 id="члены-типа" tabindex="-1"><a class="header-anchor" href="#члены-типа"><span>Члены типа</span></a></h2><p>В типе можно определить следующие члены:</p><ul><li><strong>Константа</strong> - идентификатор, определяющий некоторую постоянную величину; используются, чтобы упростить чтение кода и для удобства сопровождения и поддержки; константы связаны с типом, а не с экземпляром; на логическом уровне всегда являются статическими членами.</li><li><strong>Поле</strong> - значение данных для чтения и/или записи; может быть статическим, тогда оно является частью состояния типа, или экземплярным - тогда является состоянием конкретного объекта; доступ к полям стоит ограничивать.</li><li><strong>Конструктор экземпляров</strong> - служит для инициализации полей при создании экземпляра.</li><li><strong>Конструктор типа</strong> - служит для инициализации статических полей типа.</li><li><strong>Метод</strong> - функция, выполняющая операции, которые заменяют или запрашивают состояние типа (статический метод) или объекта (экземплярный метод).</li><li><strong>Перегруженный оператор</strong> - определяет поведение, которое необходимо проделать с объектом при применении к нему конкретного оператора; не входит в CLS.</li><li><strong>Оператор преобразования</strong> - метод, задающий порядок явного или неявного преобразования объекта из одного типа в другой; не входит в CLS.</li><li><strong>Свойство</strong> - механизм, позволяющий применить простой синтаксис для получения или установки части логического состояния типа или объекта с контролем логической целостности; бывают необобщёнными и обобщёнными (индексатор - редкий случай, в основном в классах коллекций); в метаданных создаёт два метода с префиксами <code>get_</code> и <code>set_</code>.</li><li><strong>Событие</strong> - механизм, позволяющий типу отправлять уведомления статическим или экземплярным методам; события инициируются в ответ на изменение состояния типа или объекта; состоит из двух методов: регистрации и отмены подписки на событие; использует поле-делегат для управления набором зарегистрированных методов; в метаданных создаёт само событие, а также два метода с префиксами <code>add_</code> и <code>remove_</code>.</li><li><strong>Тип</strong> - определяет вложенные типы; применяется для разбиения большого, сложного типа на небольшие блоки с целью упростить реализацию.</li></ul><h2 id="видимость-типа" tabindex="-1"><a class="header-anchor" href="#видимость-типа"><span>Видимость типа</span></a></h2><p>При определении типа с видимостью в рамках файла, а не другого типа, его можно сделать <em>открытым</em> (public) или <em>внутренним</em> (internal). По умолчанию компилятор C# делает тип внутренним, доступным только внутри сборки</p><h3 id="дружественные-сборки" tabindex="-1"><a class="header-anchor" href="#дружественные-сборки"><span>Дружественные сборки</span></a></h3><p>Иногда случается ситуация, когда необходимо сделать типы из одной сборки видимыми для другой сборки, при этом не делая их общедоступными. Для этого есть механизм <em>дружественных сборок</em> (friend assemblies). Дружественная сборка определяется именем и открытым ключом.</p><h2 id="доступ-к-членам-типов" tabindex="-1"><a class="header-anchor" href="#доступ-к-членам-типов"><span>Доступ к членам типов</span></a></h2><p>При определении члена типа можно указать модификатор доступа к члену. Модификаторы определяют, на какие члены можно ссылаться из кода. В CLR имеется свой набор возможных модификаторов, но в каждом языке свой синтаксис и термины. Ниже представлено шесть модификаторов: от максимального ограничения доступности до минимального.</p><table><thead><tr><th>CLR</th><th>C#</th><th>Описание</th></tr></thead><tbody><tr><td>Private (закрытый)</td><td>private</td><td>Доступен только внутри типа и вложенных типов</td></tr><tr><td>Family (родовой)</td><td>protected</td><td>Доступен только методам в определяющем типе (прим. <em>здесь и далее определяющий тип ВКЛЮЧАЕТ вложенные типы</em>) или в одном из производных типов независимо от сборки</td></tr><tr><td>Family and Assembly (родовой и сборочный)</td><td>private protected (начиная с C# 7.2)</td><td>Доступен в определяющем типе и производных типах в определяющей сборке</td></tr><tr><td>Assembly (сборочный)</td><td>internal</td><td>Доступен в определяющей сборке</td></tr><tr><td>Assembly or Family (сборочный или родовой)</td><td>protected internal</td><td>Доступен во вложенном и производном типах, а также в определяющей сборки</td></tr><tr><td>Public (открытый)</td><td>public</td><td>Доступен всем методами во всех сборках</td></tr></tbody></table><p>Верификация IL-кода гарантирует правильность обработки модификаторов доступа к членам в период выполнения, даже если компилятор проигнорировал эту проверку.</p><p>Если модификатор доступа не указан явно, то компилятор применяет наиболее строгий из всех - <code>private</code>. Начиная с C# 8 можно явно указывать модификаторы доступа к членам интерфейса, теперь они не обязательно должны быть открытыми, как раньше.</p><p>Компилятор C# требует, чтобы у членов базового и производного типов были одинаковые модификаторы доступа. При наследовании позволено снижать, но не повышать ограничения доступности члена, так как разработчик мог бы легко получить доступ к методу через приведение к базовому типу.</p><h2 id="статические-классы" tabindex="-1"><a class="header-anchor" href="#статические-классы"><span>Статические классы</span></a></h2><p>Существуют классы, не предназначенные для создания экземпляров. В сущности, они нужны для группировки логически связанных членов. В C# такие классы определяются ключевым словом <code>static</code>. Его разрешается применять только к классам, но не структурам, так как CLR всегда разрешает создавать экземпляры значимых типов и нет способа обойти это ограничение.</p><p>Компилятор накладывает на статический класс ряд ограничений:</p><ul><li>Класс должен быть прямым потомком <code>System.Object</code> - наследование от любого другого класса не имеет смысла, так как наследование применимо к объектам, а создать экземпляр статического класса невозможно.</li><li>Класс не должен реализовывать никаких интерфейсов, так как методы интерфейса можно вызвать через экземпляры класса.</li><li>В классе можно определять только статические члены. Любые экземплярные члены вызовут ошибку компиляции.</li><li>Класс нельзя использовать в качестве поля, параметра метода или локальной переменной, так как это подразумевает существование экземпляра. В этом случае компилятор вернёт сообщение об ошибке.</li></ul><h2 id="частичные-классы-структуры-и-интерфеисы" tabindex="-1"><a class="header-anchor" href="#частичные-классы-структуры-и-интерфеисы"><span>Частичные классы, структуры и интерфейсы</span></a></h2><p>Ключевое слово <code>partial</code> говорит компилятору C#, что исходный код типа может располагаться в нескольких файлах. Компилятор собирает их вместе на этапе компиляции, так как CLR работает с полными определениями типов. Для использования частичных классов есть три основные причины:</p><ul><li><strong>Управление версиями.</strong> Частичные классы используют, когда над одним типом могут трудиться несколько разработчиков. Разделение на частичные классы может избежать конфликтов.</li><li><strong>Разделение типа на логические модули внутри файла.</strong> Иногда требуется создать один тип для решения разных задач. Тогда этот тип можно разделить и в каждой части реализовать аспект, который необходим в данном случае. Это позволяет упростить наблюдение за членами, обеспечивающими единую функциональность и объединёнными в группу.</li><li><strong>Разделители кода.</strong> Иногда часть кода генерируется автоматически при создании проекта. И чтобы этот код не смешивался с исходным кодом разработчика, его выносят в отдельный частичный класс.</li></ul><p>Частичные типы реализуются только компилятором C#, так что все файлы с исходным кодом должны быть написаны на одном языке.</p><h2 id="компоненты-полиморфизм-и-версии" tabindex="-1"><a class="header-anchor" href="#компоненты-полиморфизм-и-версии"><span>Компоненты, полиморфизм и версии</span></a></h2><p>ООП существует уже давно. В поздние 70-е и ранние 80-е годы приложения были гораздо меньше и разрабатывались в одной компании Современные же приложения состоят из компонентов, разработанных многими компаниями. Компоненты объединяются в приложение в рамках ООП.</p><p>При компонентной разработке (Component Software Programming, CSP) идеи ООП используются на уровне компонентов. Вот основные их свойства:</p><ul><li>Компонент (сборка в .NET) можно публиковать.</li><li>Компоненты уникальны и идентифицируются по имени, версии, региональным стандартам и открытому ключу.</li><li>Компонент сохраняет свою уникальность (код одной сборки никогда статически не связывается с другой сборкой, в .NET используется динамическое связывание).</li><li>В компоненте всегда чётко указана зависимость от других компонентов (ссылочные таблицы метаданных).</li><li>В компоненте документированы его классы и члены. В C# даже разрешается включать в код компонента XML-документацию.</li><li>В компоненте определяются требуемые разрешения на доступ. Для этого в CLR существует механизм защиты доступа к коду (Code Access Security, CAS).</li><li>Опубликованный компонентном интерфейс (объектная модель) не изменяется в его служебных версиях. <em>Служебной версией</em> (servicing) называют новую версию компонента, обратно совместимую с оригинальной. Обычно служебная версия содержит исправления ошибок, но не новые зависимости или разрешения безопасности.</li></ul><p>В компонентном программировании большое внимание уделяют управлению версиями. В компоненты вносятся изменения, они поставляются в разное время. Это существенно усложняет компонентное программирование по сравнению с классическим ООП, где всё приложение пишет, тестирует и поставляет одна компания.</p><p>В .NET номер версии состоит из четырёх частей: <em>основного</em> (major), <em>дополнительного</em> (minor), номер <em>построения</em> (build) и номер <em>редакции</em> (revision). В случае изменения функциональности меняются основной и дополнительный номера, в случае исправлений - построения и редакции.</p><p>Проблемы управления версиями возникают, когда тип, определённый в одном компоненте, является базовым для типа в другом компоненте. Эти проблемы особенно характерны для полиморфизма, когда в производном типе переопределяются виртуальные методы.</p><p>В C# есть пять ключевых слов, которые непосредственно связаны с управлением версиями.</p><h5 id="модификаторы-наследования" tabindex="-1"><a class="header-anchor" href="#модификаторы-наследования"><span>Модификаторы наследования</span></a></h5><table><thead><tr><th>Ключевое слово C#</th><th>Тип</th><th>Метод/Свойство/Событие</th><th>Константа/Поле</th></tr></thead><tbody><tr><td>abstract</td><td>Нельзя создать экземпляр этого типа.</td><td>Член необходимо переопределить и реализовать в производном типе - после этого можно создать экземпляр производного типа.</td><td>(запрещено)</td></tr><tr><td>virtual</td><td>(запрещено)</td><td>Член можно переопределять в производном типе</td><td>(запрещено)</td></tr><tr><td>override</td><td>(запрещено)</td><td>Член переопределяется в производном типе</td><td>(запрещено)</td></tr><tr><td>sealed</td><td>Тип нельзя использовать в качестве базового.</td><td>Член нельзя переопределить в производном типе. Можно применить только к методу, переопределяющему виртуальный метод.</td><td>(запрещено)</td></tr><tr><td>new</td><td colspan="3">Означает, что член никак не связан с похожим членом из базового класса (применяется по умолчанию при описании члена с похожим названием)</td></tr></tbody></table><h3 id="вызов-виртуальных-методов-своиств-и-событии-в-clr" tabindex="-1"><a class="header-anchor" href="#вызов-виртуальных-методов-своиств-и-событии-в-clr"><span>Вызов виртуальных методов, свойств и событий в CLR</span></a></h3><p>Методы содержат код, выполняющий некоторые действия над типом (статические методы) или над объектом (экземплярные методы). У каждого метода есть имя, сигнатура и возвращаемый тип (иногда может быть пустым, <code>void</code>). У типа может быть несколько методов с одинаковым именем, но с разным числом параметров или с разными возвращаемыми значениями. Можно также объявить метод с одними и теми же именем и параметрами, но с разными возвращаемыми значениями (хотя большинство языков это не используют, за исключением IL).</p><p>Есть класс с тремя различными вариантами методов:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Невиртуальный экземплярный метод</span>
    <span class="token keyword">public</span> <span class="token return-type class-name">Int32</span> GetYearsEmployed <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// Виртуальный метод (виртуальный - значит, экземплярный)</span>
    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">String</span> GetProgressReport <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// Статический метод</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Employee</span> <span class="token function">Lookup</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>При компиляции этого кода компилятор помещает три записи в таблицу определений методов сборки. Каждая запись содержит флаги, указывающие, является ли метод экземплярным, виртуальным или статическим.</p><p>При компиляции кода, ссылающегося на эти методы, компилятор проверяет флаги, чтобы определить, какой IL-код необходимо вставить для корректного вызова. В CLR есть две инструкции для вызова методов:</p><ul><li>Инструкция <code>call</code> используется для вызова любых методов. Если вызвался статический метод, то необходимо указать тип, где определяется метод. При вызове экземплярного или виртуального метода необходимо указать переменную, ссылающуюся на объект (подразумевается, что переменная не <code>null</code>). Сам тип переменной указывает, в каком типе определён необходимый метод. Если метод не определён в типе, то проверяются базовые типы. Инструкция часто используется для невиртуального вызова виртуальных методов.</li><li>Инструкция <code>callvirt</code> используется для вызова экземплярных и виртуальных методов. При вызове необходимо указать переменную. Если с помощью этой инструкции вызывается невиртуальный метод, тип показывает, где определён метод. При вызове виртуального метода, CLR определяет настоящий тип объекта и вызывает метод полиморфно. При компиляции такого метода происходит проверка на <code>null</code>, из-за чего метод работает чуть медленнее.</li></ul><p>Компилятор C# часто использует именно инструкцию <code>callvirt</code> для вызова невиртуальных экземплярных методов, чтобы спровоцировать проверку на <code>null</code>.</p><p>Компиляторы стремятся использовать инструкцию <code>call</code> для вызова методов значимого типа, потому что они запечатаны. В этом случае полиморфизм невозможен, как и нуллабильность этого объекта по природе его типа. Наконец, для виртуального вызова виртуального метода значимого типа необходима упаковка, что увеличит частоту сборки мусора и снизит производительность.</p><p>При проектировании типов стоит стремиться свести к минимуму число виртуальных методов, так как они замедляют приложение и усложняют контроль версий. Виртуальный стоит делать только наиболее функциональный метод в типе.</p><h3 id="разумное-использование-видимости-типов-и-модификаторов-доступа-к-членам" tabindex="-1"><a class="header-anchor" href="#разумное-использование-видимости-типов-и-модификаторов-доступа-к-членам"><span>Разумное использование видимости типов и модификаторов доступа к членам</span></a></h3><p>Автор считает, что компилятором стоит по умолчанию делать классы запечатанными по следующим причинам:</p><ul><li><strong>Управление версиями.</strong> Если класс изначально сделан запечатанным, то его впоследствии можно сделать незапечатанным, не нарушая совместимости. Однако обратное невозможно. Кроме того, если в незапечатанном классе определены незапечатанные виртуальные методы, необходимо сохранять порядок вызовов, иначе в будущем возникнут проблемы с производными типами.</li><li><strong>Производительность.</strong> При вызове виртуального метода в запечатанном типе, JIT-компилятор может задействовать невиртуальный вызов, так как у типа не может быть наследников.</li><li><strong>Безопасность и предсказуемость.</strong> Состояние класса должно быть надёжно защищено. Производный тип может изменять состояние базового через открытые методы и свойства.</li></ul><p>Несколько правил проектирования типов:</p><ul><li>Если класс не предназначен для наследования, его стоит запечатывать.</li><li>Все поля класса должны быть закрытыми.</li><li>Методы, свойства и события стоит объявлять закрытыми и невиртуальными. Естественно, часть методов должна быть открыта для работы с классом, но лучше не делать их защищёнными или внутренними. Хотя защищённый или внутренний член всё-таки лучше виртуального, поскольку последний предоставляет производному классу больший контроль над своим поведением.</li><li>В ООП есть принцип: &quot;Лучший метод борьбы со сложностью - добавление новых типов&quot;. Однако новые типы стоит создавать рядом, а не внутри, чтобы не усложнять обращение к вложенным типам.</li></ul><h3 id="работа-с-виртуальными-методами-при-управлении-версиями-типов" tabindex="-1"><a class="header-anchor" href="#работа-с-виртуальными-методами-при-управлении-версиями-типов"><span>Работа с виртуальными методами при управлении версиями типов</span></a></h3><p>Описывается пример, когда тип, написанный в одной компании, является производным от типа, написанного в другой компании. Здесь же описываются все те действия, через которые приходится проходить разработчикам при изменениях в исходном коде обоих типов.</p>`,49),i=[l];function d(r,p){return e(),n("div",null,i)}const o=t(s,[["render",d],["__file","ch06_TypeAndMemberBasics.html.vue"]]),h=JSON.parse('{"path":"/ru/chapters/ch06_TypeAndMemberBasics.html","title":"Основные сведения о членах и типах","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Члены типа","slug":"члены-типа","link":"#члены-типа","children":[]},{"level":2,"title":"Видимость типа","slug":"видимость-типа","link":"#видимость-типа","children":[{"level":3,"title":"Дружественные сборки","slug":"дружественные-сборки","link":"#дружественные-сборки","children":[]}]},{"level":2,"title":"Доступ к членам типов","slug":"доступ-к-членам-типов","link":"#доступ-к-членам-типов","children":[]},{"level":2,"title":"Статические классы","slug":"статические-классы","link":"#статические-классы","children":[]},{"level":2,"title":"Частичные классы, структуры и интерфейсы","slug":"частичные-классы-структуры-и-интерфеисы","link":"#частичные-классы-структуры-и-интерфеисы","children":[]},{"level":2,"title":"Компоненты, полиморфизм и версии","slug":"компоненты-полиморфизм-и-версии","link":"#компоненты-полиморфизм-и-версии","children":[{"level":3,"title":"Вызов виртуальных методов, свойств и событий в CLR","slug":"вызов-виртуальных-методов-своиств-и-событии-в-clr","link":"#вызов-виртуальных-методов-своиств-и-событии-в-clr","children":[]},{"level":3,"title":"Разумное использование видимости типов и модификаторов доступа к членам","slug":"разумное-использование-видимости-типов-и-модификаторов-доступа-к-членам","link":"#разумное-использование-видимости-типов-и-модификаторов-доступа-к-членам","children":[]},{"level":3,"title":"Работа с виртуальными методами при управлении версиями типов","slug":"работа-с-виртуальными-методами-при-управлении-версиями-типов","link":"#работа-с-виртуальными-методами-при-управлении-версиями-типов","children":[]}]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch06_TypeAndMemberBasics.md"}');export{o as comp,h as data};
