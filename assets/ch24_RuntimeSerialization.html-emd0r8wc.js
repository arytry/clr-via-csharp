import{_ as t,r,o,c as s,a as e,d as i,b as a,e as n}from"./app-IxoMmWNN.js";const c={},d=n('<h1 id="сериализация" tabindex="-1"><a class="header-anchor" href="#сериализация"><span>Сериализация</span></a></h1><p><em>Сериализацией</em> (serialization) называется процесс преобразования объекта или графа связанных объектов в поток байтов. Обратное преобразование называется <em>десериализацией</em> (deserialization). После сериализации появляется возможность дополнительной обработки данных - например, шифрования и сжатия. В .NET Framework существует встроенный механизм сериализации и десериализации.</p><h2 id="практические-пример-сериализации-десериализации" tabindex="-1"><a class="header-anchor" href="#практические-пример-сериализации-десериализации"><span>Практические пример сериализации/десериализации</span></a></h2><p><em>Модулем форматирования</em> (formatter) называется тип (он реализует <code>System.Runtime.Serialization.IFormatter</code>), умеющий сериализовывать и десериализовывать граф объектов.</p><p>Для сериализации графа объектов используется метод <code>Serialize()</code> модуля форматирования с передачей в качестве аргументов ссылку на объект потока ввода-вывода и ссылку на сериализуемый граф. Модуль форматирования знает, как сериализовать весь граф, ссылаясь на описывающие тип каждого объекта метаданные. Для отслеживания состояния экземплярных полей используется отражение. Если какие-то из полей ссылаются на другие объекты, метод сериализует и их. Кроме того, модуль форматирования умеет работать с перекрёстными ссылками и не входит в бесконечные циклы.</p><p>При десериализации методом <code>Deserialize()</code> в качестве параметра принимается поток ввода-вывода и возвращается ссылка на корневой объект десериализованного графа. При этом исследуется содержимое потока для создания экземпляров всех обнаруженных в потоке объектов.</p><p>Следует следить, чтобы сериализация и десериализация производились одним и тем же модулем форматирования. Кроме того, набор графов можно сериализовать в единый поток. Десериализация в таком случае выполняется в том же порядке.</p><p>При сериализации в поток записываются полное имя типа и идентификатор сборки. Если такая сборка не найдена в домене при десериализации, то генерируется исключение.</p><h2 id="сериализуемые-типы" tabindex="-1"><a class="header-anchor" href="#сериализуемые-типы"><span>Сериализуемые типы</span></a></h2><p>В процессе проектирования типа необходимо принять решение о возможности его сериализации. Если для типа планируется сериализация, необходимо пометить тип атрибутом <code>[Serializable]</code>. Если хотя бы один из внутренних объектов не поддерживает сериализацию, то будет сгенерировано исключение. По причинам, связанным с производительностью, модуль сериализации не проверяет возможность сериализации для всех объектов в графе. В результате этого данные в потоке ввода-вывода могут быть повреждены. Для возможности восстановления после таких ситуаций следует использовать <code>MemoryStream()</code>.</p><p>Атрибут сериализации может быть применён к классам, структурам, перечислениям и делегатам (к последним двум применяется по умолчанию). Атрибут не наследуется производными типами.</p><p>В общем случае большинство типов лучше делать сериализуемыми за исключением тех, которые могут содержать конфиденциальные или защищённые данные.</p><h2 id="управление-сериализациеи-и-десериализациеи" tabindex="-1"><a class="header-anchor" href="#управление-сериализациеи-и-десериализациеи"><span>Управление сериализацией и десериализацией</span></a></h2><p>После назначения типу атрибута сериализации все экземпляры его полей становятся сериализуемыми (внутри таких типов не стоит определять автосвойства, так как имена полей могут меняться при каждой следующей компиляции). Иногда можно указать некоторые экземпляры как не подлежащие сериализации с помощью атрибута <code>[NonSerialized]</code>. Делается это по двум причинам:</p><ul><li>Поле содержит информацию, становящуюся недействительной после десериализации.</li><li>Поля содержат легко обновляемую информацию.</li></ul><p>Подобные поля при десериализации могут содержать значение по умолчанию, а не то, которое было на момент сериализации. Решить это можно с использованием метода, помеченного атрибутом <code>[OnDeserialized]</code>.</p><h2 id="сериализация-экземпляров-типа" tabindex="-1"><a class="header-anchor" href="#сериализация-экземпляров-типа"><span>Сериализация экземпляров типа</span></a></h2><p>Алгоритм сериализации объекта, типу которого назначен атрибут <code>[Serializable]</code>:</p><ol><li>Модуль форматирования получает открытые и закрытые экземплярные поля (исключая не подлежащие сериализации) через отражение. Для каждого сериализуемого поля возвращается по одному объекту типа <code>MemberInfo</code>.</li><li>Полученный массив <code>MemberInfo</code> используется для получения массива <code>Object</code>, в котором содержатся значения полей.</li><li>Модуль форматирования записывает в поток идентификатор сборки и полное имя типа.</li><li>Модуль записывает в поток имя каждого члена и его значение из массивов.</li></ol><p>Алгоритм десериализации подобного объекта:</p><ol><li>Модуль форматирования читает из потока ввода-вывода идентификатор сборки и полное имя типа. Если сборка не загружена в домен, то модуль загружает её, при невозможности загрузки возникает исключение и десериализация останавливается. Если всё загружено успешно, то модуль получает информацию о типе десериализуемого объекта.</li><li>Под новый объект выделяется память, но не вызывается конструктор.</li><li>Тем же способом, что при сериализации, модуль создаёт массив <code>MemberInfo</code>.</li><li>Из содержащихся в потоке данных формируется массив <code>Object</code> со значениями полей.</li><li>Объекты массива перебираются и инициализируют выделенную память.</li></ol><h2 id="управление-сериализованными-и-десериализованными-данными" tabindex="-1"><a class="header-anchor" href="#управление-сериализованными-и-десериализованными-данными"><span>Управление сериализованными и десериализованными данными</span></a></h2>',22),h={href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.runtime.serialization.iserializable?view=net-8.0",target:"_blank",rel:"noopener noreferrer"},p=e("code",null,"System.Runtime.Serialization.ISerializable",-1),u=e("h3",{id:"определение-типа-реализующего-интерфеис-iserializable-не-реализуемыи-базовым-классом",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#определение-типа-реализующего-интерфеис-iserializable-не-реализуемыи-базовым-классом"},[e("span",null,"Определение типа, реализующего интерфейс ISerializable, не реализуемый базовым классом")])],-1),m=e("p",null,[i("В подобной ситуации необходимо вручную сериализовывать и десериализовывать поля базового типа, что может стать проблемой для закрытых полей. Сложности возникают также в ситуации, когда базовый и производный типы определяют поле с одинаковыми именами. В этом случае при вызове метода "),e("code",null,"SerializationInfo.AddValue()"),i(" можно использовать префиксы.")],-1),_=e("h2",{id:"контексты-потока-ввода-вывода",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#контексты-потока-ввода-вывода"},[e("span",null,"Контексты потока ввода-вывода")])],-1),f={href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.runtime.serialization.streamingcontext?view=net-8.0",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"StreamingContext",-1),S=e("code",null,"StreamingContext",-1),z=n('<h2 id="сериализация-в-другои-тип-и-десериализация-в-другои-объект" tabindex="-1"><a class="header-anchor" href="#сериализация-в-другои-тип-и-десериализация-в-другои-объект"><span>Сериализация в другой тип и десериализация в другой объект</span></a></h2><p>Несколько примеров ситуаций, когда может быть необходима сериализация и десериализация в другой тип и объект:</p><ul><li>Некоторые типы допускают существование в домене только одного экземпляра. Их часто называют <em>одноэлементными</em> (singletone). Возвращаемая после десериализации ссылка должна указывать на тот же объект.</li><li>Некоторые типы (например, связанные с отражением) допускают существование одного экземпляра на тип, сборку, член и т. д.</li><li>Для объектов, контролируемых удалённо, CLR сериализует информацию о серверном объекте та, что при десериализации на клиенте создаётся объект, являющийся <em>представителем</em> (proxy) сервера на стороне клиента.</li></ul><h2 id="суррогаты-сериализации" tabindex="-1"><a class="header-anchor" href="#суррогаты-сериализации"><span>Суррогаты сериализации</span></a></h2><p>Существует возможность переопределить поведение сериализации и десериализации при помощи кода, не принадлежащего реализации типа. Это может быть нужно в случаях:</p><ul><li>Необходима сериализация типов, для которых эта возможность не была учтена при исходном проектировании.</li><li>Возможность отображения между разными версиями одного типа.</li></ul><p>Для этого необходимо определить &quot;суррогатный тип&quot;, который возьмёт на себя всю работу по сериализации и десериализации существующего типа. Затем следует зарегистрировать экземпляр суррогатного типа, сообщив модулю форматирования, за какой существующий тип он отвечает. В результате модуль будет вызывать методы суррогатного объекта. Тип суррогата должен реализовывать <code>System.Runtime.Serialization.ISerializationSurrogate</code>.</p><h3 id="цепочка-селекторов-суррогатов" tabindex="-1"><a class="header-anchor" href="#цепочка-селекторов-суррогатов"><span>Цепочка селекторов суррогатов</span></a></h3><p>Несколько объектов <code>SurrogateSelector</code> можно связать в цепочку.</p><h2 id="переопределение-сборки-и-или-типа-при-десериализации-объекта" tabindex="-1"><a class="header-anchor" href="#переопределение-сборки-и-или-типа-при-десериализации-объекта"><span>Переопределение сборки и/или типа при десериализации объекта</span></a></h2><p>Бывают ситуации, когда механизм суррогатов сериализации оказывается недостаточно гибким:</p><ul><li>Перемещение реализации типа из одной сборки в другую.</li><li>Объект сервера сериализуется в поток, отправляемый на сторону клиента. При обработке потока клиент может десериализовать объект в совершенно другой тип.</li><li>Разработчик создаёт новую версию типа, в которую требуется десериализовать все ранее сериализованные объекты.</li></ul><p>Подобная десериализация выполняется при помощи абстрактного класса <code>System.Runtime.Serialization.SerializationBinder</code>. Достаточно определить тип, производный от этого абстрактного типа.</p><p>В процессе десериализации модуль форматирования обнаруживает привязку и для каждого обрабатываемого объекта вызывает метод <code>BindToType()</code>, передавая ему имя сборки и тип, которые требуется десериализовать. На этом этапе метод решает, какой тип следует сконструировать, и возвращает этот тип.</p>',14);function x(g,k){const l=r("ExternalLinkIcon");return o(),s("div",null,[d,e("p",null,[i("Иногда встречаются сценарии, когда использование атрибутов для сериализации недостаточно. Кроме того, работа модулей форматировании основана на отражении, что замедляет процесс. Для получения полного контроля над процедурами сериализации и десериализации и исключения отражения, тип может реализовывать интерфейс "),e("a",h,[p,a(l)]),i(". При сериализации графа модуль форматирования просматривает каждый объект. Если тип объекта реализует данный интерфейс, то он игнорирует все пользовательские атрибуты и конструирует новый объект, содержащий реальный набор всех подлежащих сериализации значений объекта.")]),u,m,_,e("p",null,[i("В разделе рассказывается подробнее про содержимое типа "),e("a",f,[b,a(l)]),i(". После создания модуля форматирования можно создать структуру "),S,i(", используя любые битовые флаги.")]),z])}const I=t(c,[["render",x],["__file","ch24_RuntimeSerialization.html.vue"]]),R=JSON.parse('{"path":"/ru/chapters/ch24_RuntimeSerialization.html","title":"Сериализация","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Практические пример сериализации/десериализации","slug":"практические-пример-сериализации-десериализации","link":"#практические-пример-сериализации-десериализации","children":[]},{"level":2,"title":"Сериализуемые типы","slug":"сериализуемые-типы","link":"#сериализуемые-типы","children":[]},{"level":2,"title":"Управление сериализацией и десериализацией","slug":"управление-сериализациеи-и-десериализациеи","link":"#управление-сериализациеи-и-десериализациеи","children":[]},{"level":2,"title":"Сериализация экземпляров типа","slug":"сериализация-экземпляров-типа","link":"#сериализация-экземпляров-типа","children":[]},{"level":2,"title":"Управление сериализованными и десериализованными данными","slug":"управление-сериализованными-и-десериализованными-данными","link":"#управление-сериализованными-и-десериализованными-данными","children":[{"level":3,"title":"Определение типа, реализующего интерфейс ISerializable, не реализуемый базовым классом","slug":"определение-типа-реализующего-интерфеис-iserializable-не-реализуемыи-базовым-классом","link":"#определение-типа-реализующего-интерфеис-iserializable-не-реализуемыи-базовым-классом","children":[]}]},{"level":2,"title":"Контексты потока ввода-вывода","slug":"контексты-потока-ввода-вывода","link":"#контексты-потока-ввода-вывода","children":[]},{"level":2,"title":"Сериализация в другой тип и десериализация в другой объект","slug":"сериализация-в-другои-тип-и-десериализация-в-другои-объект","link":"#сериализация-в-другои-тип-и-десериализация-в-другои-объект","children":[]},{"level":2,"title":"Суррогаты сериализации","slug":"суррогаты-сериализации","link":"#суррогаты-сериализации","children":[{"level":3,"title":"Цепочка селекторов суррогатов","slug":"цепочка-селекторов-суррогатов","link":"#цепочка-селекторов-суррогатов","children":[]}]},{"level":2,"title":"Переопределение сборки и/или типа при десериализации объекта","slug":"переопределение-сборки-и-или-типа-при-десериализации-объекта","link":"#переопределение-сборки-и-или-типа-при-десериализации-объекта","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch24_RuntimeSerialization.md"}');export{I as comp,R as data};
