<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <link rel="icon" href="/assets/img/favicon.ico"><title>第 19 章 可空值类型 | CLR via C#</title><meta name="description" content="CLR via C# 第四版">
    <link rel="preload" href="/clr-via-csharp/assets/style-FaCSB-_p.css" as="style"><link rel="stylesheet" href="/clr-via-csharp/assets/style-FaCSB-_p.css">
    <link rel="modulepreload" href="/clr-via-csharp/assets/app-IxoMmWNN.js"><link rel="modulepreload" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-BkMiV6yx.js">
    <link rel="prefetch" href="/clr-via-csharp/assets/index.html-ZkH5qKEm.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-BvaI8qfN.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-D-7172Jl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BLQSYEbL.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-Cmb5tXx5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-C65m3L6w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-MhrBc603.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BExRN6IU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-Cwf82xZd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-U9jK40Ei.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CUDFuVYa.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-0oTJyJmn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-LLUaep7w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-Bi9j89Ya.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-Dbx7WK6o.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-DsmoFQbF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-noMBAT3f.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-MFb5H9zK.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-ZDLMr6H2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DYgFyOwD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-BtysPki2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CDUugoVg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BWeh_aT3.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-CfeNN69i.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-D16BElAb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-DK1leolo.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-CQ2ygEuE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-C3cvw10V.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-CMPdATok.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-CTieDbCf.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CJcp4OCy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-CFsstSQQ.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-beZI77Lv.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-Bi67Yt5h.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-dvExR8Gk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-GDcN_xMH.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BwKxRLwh.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-BMQPeoI2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-27zHcXlW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-CVDf2x4Y.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-DkaxxntM.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-BGwRCWdf.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-D2jgyLeB.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CcZqtO9s.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-Cgf_mCwx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-CO8XAMmW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-DZ5a5JQg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-D0mGmkov.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-BGdd7LBY.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-DExRFCv1.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BiTZ-5od.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-Dsjpqw47.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DWEP33D9.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-DtaR-VvP.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CvrkASkk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BuN-nGuz.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-f0AOnmUF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-C4pcwqj-.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-CHZCU__5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-emd0r8wc.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-BmMk3Oqy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-DDuBq2h_.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DXXfHTUn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CwFR1TuA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-Bjaf8DNA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-D2MW45gx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-Bpkc--tR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BPnkWvJ8.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-q0yDwRpt.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-BjqQ7sdC.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-BIIy8leD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BOo-9fso.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-DzDrvZ87.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-CASmG777.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CEM163Qb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-BkR6SOXn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-sfPfXudR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-LJfkVvEp.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-CSXiWNpq.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-CBasocgy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-o4yS52Dy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BZtqvWYE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-CGp-_Jrw.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-tcKP_pXy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-B6RvN9hy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BsTwrSmr.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-BDn6rSrD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-Bi_35IQj.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-stJPEo8t.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-BexV0ImS.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-Cw_fsfmx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-QnhhtSZl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DNJcQUkI.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-BAwtWkjU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-5-bQNQmT.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-DKmbpj4c.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-GASyXvmd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-D6bO62ut.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/404.html-5gOqppNC.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/clr-via-csharp/"><img class="logo" src="/clr-via-csharp/assets/images/cover.jpg" alt="CLR via C#"><span class="site-name can-hide" aria-hidden="true">CLR via C#</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/ru/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">选择语言</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/ru/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/introduction.html" aria-label="前言"><!--[--><!--[--><!--]--> 前言 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/foreword.html" aria-label="序言"><!--[--><!--[--><!--]--> 序言 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch01_TheCLRSExecutionMode.html" aria-label="第1章 CLR的执行模型"><!--[--><!--[--><!--]--> 第1章 CLR的执行模型 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch02_Building.html" aria-label="第 2 章 生成、打包、部署和管理应用程序及类型"><!--[--><!--[--><!--]--> 第 2 章 生成、打包、部署和管理应用程序及类型 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch03_SharedAssemblies.html" aria-label="第 3 章 共享程序集和强命名程序集"><!--[--><!--[--><!--]--> 第 3 章 共享程序集和强命名程序集 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch04_TypeFundamentals.html" aria-label="第 4 章 类型基础"><!--[--><!--[--><!--]--> 第 4 章 类型基础 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch05_PrimitiveRefValType.html" aria-label="第 5 章 基元类型、引用类型和值类型"><!--[--><!--[--><!--]--> 第 5 章 基元类型、引用类型和值类型 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch06_TypeAndMemberBasics.html" aria-label="第 6 章 类型和成员基础"><!--[--><!--[--><!--]--> 第 6 章 类型和成员基础 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch07_ConstantsAndFields.html" aria-label="第 7 章 常量和字段"><!--[--><!--[--><!--]--> 第 7 章 常量和字段 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch08_Methods.html" aria-label="第 8 章 方法"><!--[--><!--[--><!--]--> 第 8 章 方法 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch09_Parameters.html" aria-label="第 9 章 参数"><!--[--><!--[--><!--]--> 第 9 章 参数 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch10_Properties.html" aria-label="第 10 章 属性"><!--[--><!--[--><!--]--> 第 10 章 属性 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch11_Events.html" aria-label="第 11 章 事  件"><!--[--><!--[--><!--]--> 第 11 章 事  件 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch12_Generics.html" aria-label="第 12 章 泛型"><!--[--><!--[--><!--]--> 第 12 章 泛型 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch13_Interfaces.html" aria-label="第 13 章 接口"><!--[--><!--[--><!--]--> 第 13 章 接口 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch14_CharStringText.html" aria-label="第 14 章 字符、字符串和文本处理"><!--[--><!--[--><!--]--> 第 14 章 字符、字符串和文本处理 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch15_EnumeratedTypes.html" aria-label="第 15 章 枚举类型和位标志"><!--[--><!--[--><!--]--> 第 15 章 枚举类型和位标志 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch16_Arrays.html" aria-label="第 16 章 数组"><!--[--><!--[--><!--]--> 第 16 章 数组 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch17_Delegates.html" aria-label="第 17 章 委托"><!--[--><!--[--><!--]--> 第 17 章 委托 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch18_CustomAttributes.html" aria-label="第 18 章 定制特性"><!--[--><!--[--><!--]--> 第 18 章 定制特性 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch19_NullableValueTypes.html" aria-label="第 19 章 可空值类型"><!--[--><!--[--><!--]--> 第 19 章 可空值类型 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch20_ExceptionsAndStateManae.html" aria-label="第 20 章 异常和状态管理"><!--[--><!--[--><!--]--> 第 20 章 异常和状态管理 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch21_ManagedHeapGarbage.html" aria-label="第 21 章 托管堆和垃圾回收"><!--[--><!--[--><!--]--> 第 21 章 托管堆和垃圾回收 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch22_CLRHostingAndAppDomain.html" aria-label="第 22 章 CLR 寄宿和 AppDomain"><!--[--><!--[--><!--]--> 第 22 章 CLR 寄宿和 AppDomain <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch23_AssemblyLoaingReflection.html" aria-label="第 23 章 程序集加载和反射"><!--[--><!--[--><!--]--> 第 23 章 程序集加载和反射 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch24_RuntimeSerialization.html" aria-label="第 24 章 运行时序列化"><!--[--><!--[--><!--]--> 第 24 章 运行时序列化 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch25_WinRTComponents.html" aria-label="第 25 章 与 WinRT 组件互操作"><!--[--><!--[--><!--]--> 第 25 章 与 WinRT 组件互操作 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch26_ThreadBasics.html" aria-label="第 26 章 线程基础"><!--[--><!--[--><!--]--> 第 26 章 线程基础 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch27_ComputeBoundAsync.html" aria-label="第 27 章 计算限制的异步操作"><!--[--><!--[--><!--]--> 第 27 章 计算限制的异步操作 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch28_IOBoundAsyncOperations.html" aria-label="第 28 章 I/O 限制的异步操作"><!--[--><!--[--><!--]--> 第 28 章 I/O 限制的异步操作 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch29_PrimitiveThreadSyncConstructs.html" aria-label="第 29 章 基元线程同步构造"><!--[--><!--[--><!--]--> 第 29 章 基元线程同步构造 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/ch30_hybridThreadSyncConst.html" aria-label="第 30 章 混合线程同步构造"><!--[--><!--[--><!--]--> 第 30 章 混合线程同步构造 <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/chapters/Postscript.html" aria-label="译者后记"><!--[--><!--[--><!--]--> 译者后记 <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="第-19-章-可空值类型" tabindex="-1"><a class="header-anchor" href="#第-19-章-可空值类型"><span>第 19 章 可空值类型</span></a></h1><p>本章内容</p><ul><li><a href="#19_1">C# 对可空值类型的支持</a></li><li><a href="#19_2">C# 的空接合操作符</a></li><li><a href="#19_3">C# 对可空值类型的特殊支持</a></li></ul><p>我们知道值类型的变量永远不会为 <code>null</code>；它总是包含值类型的值本身。事实上，这正是“值类型”一次的由来。遗憾的是，这在某些情况下会成为问题。例如，设计数据库时，可将一个列的数据类型定义成一个 32 位整数，并映射到 FCL(Framework Class Library)的 <code>Int32</code> 数据类型。但是，数据库中的一个列可能允许值为空；也就是说，该列在某一行上允许没有任何值。用 Microsoft .NET Framework 处理数据库数据可能变得很困难，因为在 CLR 中，没有办法将 <code>Int32</code> 值表示成 <code>null</code>。</p><blockquote><p>注意 Microsoft ADO.NET 的表适配器(table adapter)确实支持可空类型。遗憾的是 <code>System.Data.SqlTypes</code> 命名空间中的类型没有用可空类型替换，部分原因是类型之间没有“一对一”的对应关系。例如，<code>SqlDecimal</code> 类型最大允许 38 位数，而普通的 <code>Decimal</code> 类型最大允许 38 位数，而普通的 <code>Decimal</code> 类型最大只允许 29 位数。此外， <code>SqlString</code> 类型支持它自己的本地化和比较选项，而普通的 <code>String</code> 类型并不支持这些。</p></blockquote><p>下面是以另一个例子：Java 的 <code>java.util.Date</code> 类是引用类型，所以该类型的变量能设为 <code>null</code>。但 CLR 的 <code>System.DateTime</code> 是值类型，<code>DateTime</code> 变量永远不能设为 <code>null</code>。如果用 Java 写的一个应用程序想和运行 CLR 的 Web 服务交流日期/时间，那么一旦 Java 程序发送 <code>null</code>，就会出问题，因为 CLR 不知道如何表示 <code>null</code>，也不知道如何操作它。</p><p>为了解决这个问题， Microsoft 在 CLR 中引入了<strong>可空值类型</strong>的概念。为了理解它们是如何工作的，先来看看 FCL 中定义的 <code>System.Nullable&lt;T&gt;</code>结构。以下是<code>System.Nullable&lt;T&gt;</code>定义的逻辑表示：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>using System;
using System.Runtime.InteropServices;

[Serializable, StructLayout(LayoutKind.Sequential)]
public struct Nullable&lt;T&gt; where T : struct {
    // 这两个字段表示状态
    private Boolean hasValue = false;       // 假定 null
    internal T value = default(T);          // 假定所有位都为零

    public Nullable(T value) {
        this.value = value;
        this.hasValue = true;
    }

    public Boolean HasValue { get { return hasValue; } }

    public T Value {
        get {
            if (!hasValue) {
                throw new InvalidOperationException(&quot;Nullable object must have a value.&quot;);
            }
            return value;
        }
    }

    public T GetValueOrDefault() { return value; }

    public T GetValueOrDefault(T defaultValue) {
        if (!HasValue) return defaultValue;
        return value;
    }

    public override Boolean Equals(object other) {
        if (!HasValue) return (other == null);
        if (other == null) return false;
        return value.Equals(other);
    }

    public override int GetHashCode() {
        if (!HasValue) return 0;
        return value.GetHashCode();
    }

    public override string ToString() {
        if (!HasValue) return &quot;&quot;;
        return value.ToString();
    }

    public static implicit operator Nullable&lt;T&gt;(T value) {
        return new Nullable&lt;T&gt;(value);
    }

    public static explicit operator T(Nullable&lt;T&gt; value) {
        return value.Value;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出，该结构能表示可为 <code>null</code> 的值类型。由于 <code>Nullable&lt;T&gt;</code> 本身是值类型，所以它的实例仍然是“轻量级”的。也就是说，实例仍然可以在栈上，而且实例的大小和原始值类型基本一样，只是多了一个 <code>Boolean</code> 字段。注意 <code>Nullable</code> 的类型参数 <code>T</code> 被约束为<code>struct</code>。这是由于引用类型的变量本来就可以为 <code>null</code>，所以没必要再去照顾它。</p><p>现在，要在代码中使用一个可空的 <code>Int32</code>，就可以像下面这样写：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>Nullable&lt;Int32&gt; x = 5;
Nullable&lt;Int32&gt; y = null;
Console.WriteLine(&quot;x: HasValue={0}, Value={1}&quot;, x.HasValue, x.Value);
Console.WriteLine(&quot;y: HasValue={0}, Value={1}&quot;, y.HasValue, y.GetValueOrDefault());
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译并运行上述代码，将获得以下输出：</p><div class="language-cmd line-numbers-mode" data-ext="cmd" data-title="cmd"><pre class="language-cmd"><code>x: HasValue=True, Value=5
y: HasValue=False, Value=0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_19-1-c-对可空值类型的支持" tabindex="-1"><a class="header-anchor" href="#_19-1-c-对可空值类型的支持"><span><a name="19_1">19.1 C#对可空值类型的支持</a></span></a></h2><p>C# 允许使用相当简单的语法初始化上述两个 <code>Nullable&lt;Int32&gt;</code> 变量 <code>x</code> 和 <code>y</code>。事实上，C# 开发团队的目的是将可空值类型集成到 C# 语言中，使之成为 “一等公民”。为此，C# 提供了更清新的语法来处理可空值类型。C# 允许用问号表示法来声明并初始化 <code>x</code> 和 <code>y</code> 变量：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>Int32? x = 5;
Int32? y = null;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 C#中， <code>Int32?</code> 等价于 <code>Nullable&lt;Int32&gt;</code>。但 C# 在此基础上更进一步，允许开发人员在可空实例上执行转换和转型<sup>①</sup>。C# 还允许向可空实例应用操作符。以下代码对此进行了演示：</p><blockquote><p>① 作者在这里区分了转换和转型。例如，从 <code>Int32</code> 的可空版本到非可空版本(或相反)，称为“转换”。但是，涉及不同基元类型的转换，就称为“转型”或“强制类型转换”。 ———— 译注</p></blockquote><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>private static void ConversionsAndCasting() {
    // 从非可空 Int32 隐式转换为 Nullable&lt;Int32&gt;
    Int32? a = 5;

    // 从 &#39;null&#39; 隐式转换为 Nullable&lt;Int32&gt;
    Int32? b = null;

    // 从 Nullable&lt;Int32&gt; 显式转换为非可空 Int32
    Int32 c = (Int32) a;

    // 在可空基元类型之间转型
    Double? d = 5;      // Int32 转型为 Double? (d 是 double 值 5.0)
    Double? e = b;      // Int32?转型为 Double? (e 是 null)
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C# 还允许向可空实例应用操作符，例如：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>private static void Operators() {
    Int32? a = 5;
    Int32? b = null;

    // 一元操作符 (+ ++ - -- ! ~)
    a++;            // a = 6
    b = -b;         // b = null

    // 二元操作符 (+ - * / % &amp; | ^ &lt;&lt; &gt;&gt;)
    a = a + 3;      // a = 9;
    b = b * 3;      // b = null;

    // 相等性操作符 ((== !=)
    if (a == null) { /* no */   } else { /* yes */ }
    if (b == null) { /* yes */  } else { /* no  */ }
    if (a != b) { /* yes */     } else { /* no  */ }

    // 比较操作符 (&lt; &gt; &lt;= &gt;=)
    if (a &lt; b)          { /* no */ } else { /* yes */ }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面总结了 C# 如何解析操作符。</p><ul><li><p><strong>一元操作符(<code>+</code>，<code>++</code>，<code>-</code>，<code>--</code>，<code>!</code>，<code>~</code>)</strong> 操作数是 <code>null</code>，结果就是 <code>null</code>。</p></li><li><p><strong>二元操作符(<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>&amp;</code>，<code>|</code>，<code>^</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>))</strong> 两个操作数任何一个是 <code>null</code>，结果就是 <code>null</code>。但有一个例外，它发生在将<code>&amp;</code>和<code>|</code>操作符应用于 <code>Boolean?</code>操作数的时候。在这种情况下，两个操作符的行为和 SQL 的三值逻辑一样。对于这两个操作符，如果两个操作数都不是<code>null</code>，那么操作符和平常一样工作。如果连个操作数都是<code>null</code>，结果就是<code>null</code>。特殊行为仅在其中之一为<code>null</code>时发生。下表列出了针对操作数的<code>true</code>，<code>false</code> 和 <code>null</code>三个值的各种组合，两个操作符的求值情况。</p><table><thead><tr><th style="text-align:center;">操作数 1 → <br> 操作数2 ↑</th><th style="text-align:center;">true</th><th style="text-align:center;">false</th><th style="text-align:center;">null</th></tr></thead><tbody><tr><td style="text-align:center;">true</td><td style="text-align:center;">&amp; = true <br>| =ture</td><td style="text-align:center;">&amp; = false <br> | = true</td><td style="text-align:center;">&amp; = null <br> | = true</td></tr><tr><td style="text-align:center;">false</td><td style="text-align:center;">&amp; = false <br> | = true</td><td style="text-align:center;">&amp; = false <br> | = false</td><td style="text-align:center;">&amp; = false <br> | = null</td></tr><tr><td style="text-align:center;">null</td><td style="text-align:center;">&amp; = null <br> | = true</td><td style="text-align:center;">&amp; = false <br>| = null</td><td style="text-align:center;">&amp; = null <br>| = null</td></tr></tbody></table></li><li><p><strong>相等性操作符(<code>==</code>，<code>!=</code>)</strong> 两个操作数都是 <code>null</code>，两者相等。一个操作数是 <code>null</code>，两者不相等。两个操作数都不是 <code>null</code>，就比较值来判断是否相等。</p></li><li><p><strong>关系操作符(<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>)</strong> 两个操作数任何一个是 <code>null</code>，结果就是 <code>false</code>。两个操作数都不是 <code>null</code>，就比较值。</p></li></ul><p>注意，操作可空实例会生成大量代码。例如以下方法：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>private static Int32? NullableCodeSize(Int32? a, Int32? b) {
    return (a + b);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译这个方法会生成相当多的 IL 代码，而且操作可空类型的速度慢于非可空类型。编译器生成的 IL 代码等价于以下 C# 代码：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>private static Nullable&lt;Int32&gt; NullableCodeSize(Nullable&lt;Int32&gt; a, Nullable&lt;Int32&gt; b) {
    Nullable&lt;Int32&gt; nullable1 = a;
    Nullable&lt;Int32&gt; nullable2 = a;
    if (!(nullable1.HasValue &amp; nullable2.HasValue)) {
        return new Nullable&lt;Int32&gt;();
    }
    return new Nullable&gt;&lt;Int32&gt; (nullable1.GetvalueOrDefault() + nullable2.GetValueOrDefault());
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后要说明的是，可定义自己的值类型来重载上述各种操作符符。8.4 节 “操作符重载方法”已对此进行了讨论。使用自己的值类型的可空实例，编译器能正确识别它并调用你重载的操作符(方法)。以下 <code>Point</code> 值类型重载了 <code>==</code> 和 <code>!=</code> 操作符：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>using System;

internal struct Point {
    private Int32 m_x, m_y;
    public Point(Int32 x, Int32 y) { m_x = x; m_y = y; }

    public static Boolean operator == (Point p1, Point p2) {
        return (p1.m_x == p2.m_x) &amp;&amp; (p1.m_y == p2.m_y);
    }

    public static Boolean operator != (Point p1, Point p2) {
        return !(p1 == p2);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后可以使用 <code>Point</code> 类型的可空实例，编译器能自动调用你重载的操作符(方法):</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>Are points equal? False
Are points not equal? True
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_19-2-c-的空接合操作符" tabindex="-1"><a class="header-anchor" href="#_19-2-c-的空接合操作符"><span><a name="19_2">19.2 C#的空接合操作符</a></span></a></h2><p>C# 提供了一个“空接合操作符”(null-coalescing operator)，即<code>??</code>操作符，它要获取两个操作数。假如左边的操作数不为 <code>null</code>，就返回这个操作数的值。如果左边的操作数为 <code>null</code>，就返回右边的操作数的值。利用空接合操作符，可以方便地设置变量的默认值。</p><p>空接合操作符的一个好处在于，它既能用于引用类型，也能用于可空值类型。以下代码演示了如何使用 <code>??</code> 操作符：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>private static void NullCoalescingOperator() {
    Int32? b = null;

    // 下面这行等价于：
    // x = (b.HasValue) ? b.Value : 123
    Int32 x = b ?? 123;
    Console.WriteLine(x);           // &quot;123&quot;

    // 下面这行等价于：
    // String temp = GetFilename();
    // filename = (temp != null) ? temp : &quot;Untitled&quot;;
    String filename = GetFilename() ?? &quot;Untitled&quot;;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有人争辩说 <code>??</code> 操作符不过是 <code>?:</code>操作符的“语法糖”而已，所以C#编译器团队不应该将这个操作符添加到语言中。实际上，<code>??</code> 提供了重大的语法上的改进。第一个改进是<code>??</code>操作符能更好地支持表达式：</p><p><code>Func&lt;String&gt; f = () =&gt; SomeMthod() ?? &quot;Untitled&quot;;</code></p><p>相比下一行代码，上述代码更容易阅读和理解。下面这行代码要求进行变量赋值，而且用一个语句还搞不定：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>Func&lt;String&gt; f = () =&gt; { var temp = SomeMethod();
    return temp != null ? temp : &quot;Untitled&quot;; };
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个改进是 <code>??</code> 在复合情形中更好用。例如，下面这行代码：</p><p><code>String s = SomeMethod1() ?? SomeMethod2() ?? &quot;Untitled&quot;;</code></p><p>它比下面这一堆代码更容易阅读和理解：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>String s;
var sm1 = SomeMethod1();
if (sm1 != null ) s = sm1;
else {
    var sm2 = SomeMethod2();
    if (sm2 != null ) s = sm2;
    else s = &quot;Untitled&quot;;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_19-3-clr-对可空值类型的特殊支持" tabindex="-1"><a class="header-anchor" href="#_19-3-clr-对可空值类型的特殊支持"><span><a name="19_3">19.3 CLR 对可空值类型的特殊支持</a></span></a></h2><p>CLR 内建对可空值类型的支持。这个特殊的支持是针对装箱、拆箱、调用 <code>GetType</code> 和调用接口方法提供的，它使可空类型能无缝地集成到 CLR 中，而且使它们具有更自然的行为，更符合大多数开发人员的预期。下面深入研究一下 CLR 对可空类型的特殊支持。</p><h3 id="_19-3-1-可空值类型的装箱" tabindex="-1"><a class="header-anchor" href="#_19-3-1-可空值类型的装箱"><span>19.3.1 可空值类型的装箱</span></a></h3><p>假定有一个逻辑设为 <code>null</code> 的 <code>Nullable&lt;Int32&gt;</code> 变量。将其传给期待一个 <code>Object</code> 的方法，就必须对其进行装箱，并将对已装箱<code>Nullable&lt;Int32&gt;</code> 的引用传给方法。但对表面上为 <code>null</code>的值进行装箱不符合直觉————即使<code>Nullable&lt;Int32&gt;</code>变量本身非 <code>null</code>，它只是在逻辑上包含了 <code>null</code>。为了解决这个问题，CLR 会在装箱可空变量时执行一些特殊代码，从表面上维持可空类型的“一等公民”地位。</p><p>具体地说，当 CLR 对 <code>Nullable&lt;T&gt;</code> 实例进行装箱时，会检查它是否为 <code>null</code>。如果是，CLR 不装箱任何东西，直接返回 <code>null</code>。如果可空实例不为 <code>null</code>，CLR 从可空实例中取出值并进行装箱。也就是说，一个值为 5 的 <code>Nullable&lt;Int32&gt;</code> 会装箱成值为 5 的已装箱 <code>Int32</code>。以下代码演示了这一行为：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>// 对 Nullable&lt;T&gt; 进行装箱，要么返回 null，要么返回一个已装箱的 T
Int32？ n = null;
Object o = n;       // o 为 null
Console.WriteLine(&quot;o is null={0}&quot;, o == null);   // &quot;True&quot;

n = 5;
o = n;   // o 引用一个已装箱的 Int32
Console.WriteLine(&quot;o&#39;s type={0}&quot;, o.GetType()); // &quot;System.Int32&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_19-3-2-可空值类型的拆箱" tabindex="-1"><a class="header-anchor" href="#_19-3-2-可空值类型的拆箱"><span>19.3.2 可空值类型的拆箱</span></a></h3><p>CLR 允许将已装箱的值类型 <code>T</code> 拆箱为一个 <code>T</code> 或者 <code>Nullable&lt;T&gt;</code>。如果对已装箱类型的引用是 <code>null</code>，而且要把它拆箱为一个 <code>Nullable&lt;T&gt;</code>，那么 CLR 会将 <code>Nullable&lt;T&gt;</code>的值设为 <code>null</code>。以下代码演示了这个行为：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>// 创建已装箱的 Int32
Object o = 5;

// 
Int32? a = (Int32?) o;  // a = 5
Int32 b = (Int32) o;    // b = 5

// 创建初始化为 null 的一个引用
o = null;

// 把它“拆箱”为一个 Nullable&lt;Int32&gt; 和一个 Int32
a = (Int32?) o;     // a = null
b = (Int32) o;      // NullReferenceException
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_19-3-3-通过可空值类型调用-gettype" tabindex="-1"><a class="header-anchor" href="#_19-3-3-通过可空值类型调用-gettype"><span>19.3.3 通过可空值类型调用 GetType</span></a></h3><p>在 <code>Nullable&lt;T&gt;</code> 对象上调用 <code>GetType</code>，CLR实际会“撒谎”说类型是 <code>T</code>，而不是 <code>Nullable&lt;T&gt;</code>。以下代码演示了这一行为：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>Int32? x = 5;
// 下面这行会显示 &quot;System.Int32&quot;，而非“System.Nullable&lt;Int32&gt;”
Console.WriteLine(x.GetType());
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_19-3-4-通过可空值类型调用接口方法" tabindex="-1"><a class="header-anchor" href="#_19-3-4-通过可空值类型调用接口方法"><span>19.3.4 通过可空值类型调用接口方法</span></a></h3><p>以下代码将 <code>Nullable&lt;Int32&gt;</code> 类型的变量 <code>n</code> 转型为接口类型 <code>IComparable&lt;Int32&gt;</code>。<code>Nullable&lt;T&gt;</code> 不像 <code>Int32</code> 那样实现了 <code>IComparable&lt;Int32&gt;</code> 接口，但 C# 编译器允许这样的代码通过编译，而且 CLR 的校验器也认为这样的代码可验证，从而允许使用更简洁的语法：</p><div class="language-C# line-numbers-mode" data-ext="C#" data-title="C#"><pre class="language-C#"><code>Int32? n = 5;
Int32 result = ((IComparable) n).CompareTo(5);      // 能顺利编译和运行
Console.WriteLine(result);                          // 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如 CLR 不提供这一特殊支持，要在可空值类型上调用接口方法，就必须写很繁琐的代码。首先要转型为已拆箱的值类型，然后才能转型为接口以出发调用：</p><p><code>Int32 result = ((IComparable) (Int32) n).CompareTo(5); // 很繁琐</code></p></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="external-link label" href="https://github.com/arytry/clr-via-csharp/edit/main/docs/zh/chapters/ch19_NullableValueTypes.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页"><!--[--><!--[--><svg class="icon" viewBox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]--> 在 GitHub 上编辑此页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/clr-via-csharp/assets/app-IxoMmWNN.js" defer></script>
  </body>
</html>
