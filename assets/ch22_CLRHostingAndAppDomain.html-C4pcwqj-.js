import{_ as e,o as l,c as i,e as a}from"./app-IxoMmWNN.js";const r={},s=a('<h1 id="хостинг-clr-и-домены-приложении" tabindex="-1"><a class="header-anchor" href="#хостинг-clr-и-домены-приложении"><span>Хостинг CLR и домены приложений</span></a></h1><p>По-настоящему оценить достоинства .NET Framework помогают <em>хостинг</em> (hosting) и <em>домены приложений</em> (AppDomains). Благодаря хостингу любое приложение может использовать возможности CLR: переписать приложение при помощи управляемого кода, а также настраивать и дополнять приложение на программном уровне.</p><p>Домены приложений позволяют решить проблему, при которой загрузка чужих DLL-библиотек могла нарушить безопасность среды.</p><h2 id="хостинг-clr" tabindex="-1"><a class="header-anchor" href="#хостинг-clr"><span>Хостинг CLR</span></a></h2><p>.NET Framework работает поверх Windows, а значит, файлы управляемых модулей и сборок должны иметь формат PE, являться исполняемыми файлами (EXE) или динамически подключаемыми библиотеками (DLL). В Microsoft разработали CLR в виде COM-сервера, содержащегося в DLL. При установке .NET Framework COM-сервер, представляющий CLR, регистрируется в реестре. Любое приложение может стать хостом (управляющим приложением) для CLR. Для создания экземпляра CLR стоит использовать специальную функцию, определённую в библиотеке MSCorEE.dll. Эту библиотеку называют <em>оболочкой совместимости</em> (shim) - она не содержит COM-сервер, но определяет, какую версию CLR необходимо создать. На одной машине может быть несколько версий CLR, но только одна версия оболочки совместимости. Версия MSCorEE.dll совпадает с версией самой последней установленной CLR, так что она знает, как найти предыдущие версии.</p><p>Хост-приложение может выполнять следующие операции:</p><ul><li>Устанавливать хост-диспетчеры (host managers), занимающиеся выделением памяти, планированием и синхронизацией потоков, загрузкой сборок и т. п.</li><li>Получать информацию о CLR-диспетчерах, то есть запрещать использовать определённые классы или члены. Хост также может указать подлежащий отладке код, а также методы, вызываемые при определённых событиях (выгрузка домена, исключения и т.д.).</li><li>Инициализировать и запускать CLR.</li><li>Загружать сборку и исполнять её код.</li><li>Останавливать CLR.</li></ul><h2 id="домены-приложении" tabindex="-1"><a class="header-anchor" href="#домены-приложении"><span>Домены приложений</span></a></h2><p>В ходе инициализации COM-сервер CLR создаёт домен приложений, который является логическим контейнером для набора сборок. Первый из созданных доменов называют <em>основным</em> (default AppDomain), он уничтожается только при завершении процесса. Помимо основного могут создаваться также и дополнительные. Домены удобны благодаря ряду свойств:</p><ul><li><strong>Объекты, созданные одним доменом приложения, недоступны коду других доменов.</strong> Время жизни объекта ограничивается временем жизни домена. Код другого домена может получить доступ к объекту только при помощи <em>продвижения по ссылке</em> (marshal-by-reference) или <em>по значению</em> (marshal-by-value).</li><li><strong>Домены приложений можно выгружать.</strong></li><li><strong>Домены приложений можно индивидуально защищать.</strong> Домену приложений можно назначить набор разрешений.</li><li><strong>Домены приложений можно индивидуально настраивать.</strong></li></ul><p><img src="https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/00b658c4-0a4a-438e-a65c-fc4c5135537e" alt="image"></p><p>У каждого домена есть своя куча загрузчика, ведущая учёт обращения к типу. Если сборка используется в нескольких доменах, то она загружается в каждый домен отдельно, так как домены разрабатывались для изоляции. Однако, существуют сборки для совместного использования. Они загружаются отдельно и выгружаются при завершении процесса.</p><h3 id="доступ-к-объектам-из-других-доменов" tabindex="-1"><a class="header-anchor" href="#доступ-к-объектам-из-других-доменов"><span>Доступ к объектам из других доменов</span></a></h3><p>Код, расположенный в одном домене, способен взаимодействовать с типами и объектами другого домена через тщательно определённые механизмы.</p><p>В книге описывается несколько примеров доступа к объектам из другого домена, среди которых</p><ol><li>Междоменное взаимодействие с продвижением по ссылке.</li><li>Междоменное взаимодействие с продвижением по значению.</li><li>Междоменное взаимодействие без продвижения.</li></ol><p>Все это расписано подробно с примерами кода.</p><h2 id="выгрузка-доменов" tabindex="-1"><a class="header-anchor" href="#выгрузка-доменов"><span>Выгрузка доменов</span></a></h2><p>Для корректной выгрузки домена CLR выполняет набор операций:</p><ol><li>Приостанавливает все потоки в процессе, которые выполняют управляемый код.</li><li>Проверяет все стеки на наличие потоков, которые выполняют или могут вернуться к коду выгружаемого домена. Генерируется <code>ThreadAbortException</code>, после которого все потоки завершают свою работу.</li><li>После выгрузки из домена всех потоков, CLR проходит по куче и устанавливает флаг, сигнализирующий, что реальные объекты уничтожены. При попытке обратиться к таким объектам возникает <code>AppDomainUnloadedException</code>.</li><li>Инициализируется принудительная сборка мусора. Для необходимых объектов вызываются методы финализации.</li><li>Возобновляется работа всех оставшихся потоков. Вызовы <code>AppDomain.Unload()</code> выполняются синхронно.</li></ol><h2 id="мониторинг-доменов" tabindex="-1"><a class="header-anchor" href="#мониторинг-доменов"><span>Мониторинг доменов</span></a></h2><p>Хост-приложение умеет отслеживать потребляемые доменом ресурсы. Некоторые хосты на основе этой информации принудительно выгружают домен, если потребление памяти или ресурсов выходит за разумные пределы. При включённом мониторинге можно использовать четыре доступных только для чтения свойства класса <code>AppDomain</code>:</p><ul><li><strong>MonitoringSurvivedProcessMemorySize.</strong> Число батов, используемых в данный момент всеми доменами под управлением текущего экземпляра CLR. Значение верно с момента последней очистки мусора.</li><li><strong>MonitoringTotalAllocatedMemorySize.</strong> Число байтов, выделенных определённым доменом. Значение верно с момента последней очистки мусора.</li><li><strong>MonitoringSurvivedMemorySize.</strong> Количество байтов, которые используются определённым доменом. Значение верно с момента последней очистки мусора.</li><li><strong>MonitoringTotalProcessorTime.</strong> Возвращает процессорное время, использованное определённым доменом.</li></ul><h2 id="уведомление-о-первом-управляемом-исключении-домена" tabindex="-1"><a class="header-anchor" href="#уведомление-о-первом-управляемом-исключении-домена"><span>Уведомление о первом управляемом исключении домена</span></a></h2><p>При первом появлении исключения CLR задействует любой из методов обратного вызова <code>FirstChanceException</code>, зарегистрированных в домене. Затем CLR ищет блоки <code>catch</code>. Если исключение обрабатывается, то выполнение возвращается в обычный режим. Если блок не найден, то исключение поднимается наверх и также задействует методы обратного вызова. Если исключение так и не удастся обработать, то CLR завершает процесс.</p><h2 id="использование-хостами-доменов-приложении" tabindex="-1"><a class="header-anchor" href="#использование-хостами-доменов-приложении"><span>Использование хостами доменов приложений</span></a></h2><h3 id="исполняемые-приложения" tabindex="-1"><a class="header-anchor" href="#исполняемые-приложения"><span>Исполняемые приложения</span></a></h3><p>Исполняемые приложения (консольное приложение, NT Service, Windows Forms и WPF) являются <em>саморазмещающимися</em> (self-hosted) и снабжены управляемыми EXE-файлами. Если процесс инициализируется при помощи такого файла, то загружается оболочка совместимости, которая через заголовочную информацию в исполняемом файле понимает, какую версию CLR необходимо загрузить в процесс. Затем заголовочные файлы исследуются снова, чтобы найти точку входа в приложение, после чего приложение начинает работу.</p><h3 id="полнофункциональные-интернет-приложения-silverlight" tabindex="-1"><a class="header-anchor" href="#полнофункциональные-интернет-приложения-silverlight"><span>Полнофункциональные интернет-приложения Silverlight</span></a></h3><p><em>Не актуально.</em></p><h3 id="microsoft-asp-net-и-веб-службы-xml" tabindex="-1"><a class="header-anchor" href="#microsoft-asp-net-и-веб-службы-xml"><span>Microsoft ASP.NET и веб-службы XML</span></a></h3><p>При первом запросе клиентом URL-адреса, обрабатываемого библиотекой ISAPI, ASP.NET загружает CLR. Если данный запрос является первым, для данного веб-приложения создаётся новый домен. Затем ASP.NET заставляет CLR выгрузить в новый домен сборку, предоставляющую нужный тип, после чего создаётся экземпляр этого типа и начинают вызываться его методы для исполнения запроса клиента. При наличии ссылок на другие типы могут загружаться дополнительные сборки. Следующие клиентские запросы обрабатываются быстрее, так как типы уже загружены и код скомпилирован.</p><p>В одном процессе могут работать несколько веб-приложений, что повышает производительность системы. Для каждого приложения создаётся свой домен.</p><p>ASP.NET обладает замечательной возможностью по изменению кода без остановки веб-сервера. Когда файл меняется, старый домен выгружается, а затем с использованием новых файлов создаётся новый домен. При этом ASP.NET использует особую функцию доменов, называемую <em>теневым копированием</em> (shadow copying).</p><h3 id="microsoft-sql-server" tabindex="-1"><a class="header-anchor" href="#microsoft-sql-server"><span>Microsoft SQL Server</span></a></h3><p>Microsoft SQL Server относится к неуправляемым приложениям, так как большая часть написана на C++. Однако он поддерживает создание хранимых процедур на управляемом коде. При первом получении запроса на выполнение хранимой процедуры на управляемом коде, сервер загружает CLR.</p><h3 id="будущее-и-мечты" tabindex="-1"><a class="header-anchor" href="#будущее-и-мечты"><span>Будущее и мечты</span></a></h3><p>В будущем планируется добавление возможности по выбору языка программирования для создания макросов, что позволит выполнять их в домене.</p><h2 id="нетривиальное-управление-хостингом" tabindex="-1"><a class="header-anchor" href="#нетривиальное-управление-хостингом"><span>Нетривиальное управление хостингом</span></a></h2><h3 id="применение-управляемого-кода" tabindex="-1"><a class="header-anchor" href="#применение-управляемого-кода"><span>Применение управляемого кода</span></a></h3><p>Для изменения заданного по умолчанию поведения CLR при помощи управляемого кода можно определить собственный класс, производный от <code>System.AppDomainManager</code>, переопределив все необходимые виртуальные методы. После этого класс надо скомпоновать в отдельную сборку и поместить в GAC.</p><h3 id="разработка-надежных-хост-приложении" tabindex="-1"><a class="header-anchor" href="#разработка-надежных-хост-приложении"><span>Разработка надёжных хост-приложений</span></a></h3><p>Хост может указать CLR, какие действия следует предпринять при сбое в управляемом коде, например:</p><ul><li>Можно прервать поток, если он выполняется слишком долго или не возвращает управление.</li><li>Можно выгрузить домен, при этом закроются все потоки, а код будет выгружен.</li><li>CLR может отключиться, при этом прекращается выполнение именно управляемого кода.</li><li>CLR может выйти из процесса, при этом сначала закрываются все потоки и выгружаются все домены.</li></ul><h3 id="возвращение-потока-в-хост" tabindex="-1"><a class="header-anchor" href="#возвращение-потока-в-хост"><span>Возвращение потока в хост</span></a></h3><p><img src="https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/cae44ddd-d638-4dbd-bebe-1e888dca49c1" alt="image"></p><p>На рисунке показана архитектура хост-приложения, пытающегося решить проблему вышедшего из-под контроля потока:</p><ol><li>Клиент направляет запрос на сервер.</li><li>Поток сервера принимает запрос и пересылает его потоку из пула для выполнения работы.</li><li>Поток из пула принимает клиентский запрос и выполняет доверенный код.</li><li>Доверенный код входит в блок <code>try</code> и вызывает из него другой домен с продвижением по ссылке. Этот домен содержит код сторонних разработчиков.</li><li>Хост фиксирует время получения исходного клиентского запроса. Если сторонний код не отвечает за определённое время, хост требует от CLR завершить поток.</li><li>Поток пула начинает завершение и выполняет код очистке. Поток возвращается в домен. Так как программа-заглушка вызвала сторонний код из блока <code>try</code>, в ней имеется и блок <code>catch</code>, который перехватывает исключение <code>ThreadAbortException</code>.</li><li>В ответ на перехват исключения хост вызывает метод <code>Thread.ResetAbort()</code>. Данный метод выполняется асинхронно. Он отмечает целевой поток специальным флагом и немедленно возвращает управление. Обнаружив завершение потока, среда пытается перенести его в <em>безопасное место</em> (safe place). Как только потом оказывается в безопасном месте, среда заставляет его выдать исключение <code>ThreadAbortException</code>, после чего поток завершается.</li><li>Хост отправляет информацию о сбое клиенту и возвращает поток в пул.</li></ol>',48),n=[s];function o(t,c){return l(),i("div",null,n)}const d=e(r,[["render",o],["__file","ch22_CLRHostingAndAppDomain.html.vue"]]),p=JSON.parse('{"path":"/ru/chapters/ch22_CLRHostingAndAppDomain.html","title":"Хостинг CLR и домены приложений","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Хостинг CLR","slug":"хостинг-clr","link":"#хостинг-clr","children":[]},{"level":2,"title":"Домены приложений","slug":"домены-приложении","link":"#домены-приложении","children":[{"level":3,"title":"Доступ к объектам из других доменов","slug":"доступ-к-объектам-из-других-доменов","link":"#доступ-к-объектам-из-других-доменов","children":[]}]},{"level":2,"title":"Выгрузка доменов","slug":"выгрузка-доменов","link":"#выгрузка-доменов","children":[]},{"level":2,"title":"Мониторинг доменов","slug":"мониторинг-доменов","link":"#мониторинг-доменов","children":[]},{"level":2,"title":"Уведомление о первом управляемом исключении домена","slug":"уведомление-о-первом-управляемом-исключении-домена","link":"#уведомление-о-первом-управляемом-исключении-домена","children":[]},{"level":2,"title":"Использование хостами доменов приложений","slug":"использование-хостами-доменов-приложении","link":"#использование-хостами-доменов-приложении","children":[{"level":3,"title":"Исполняемые приложения","slug":"исполняемые-приложения","link":"#исполняемые-приложения","children":[]},{"level":3,"title":"Полнофункциональные интернет-приложения Silverlight","slug":"полнофункциональные-интернет-приложения-silverlight","link":"#полнофункциональные-интернет-приложения-silverlight","children":[]},{"level":3,"title":"Microsoft ASP.NET и веб-службы XML","slug":"microsoft-asp-net-и-веб-службы-xml","link":"#microsoft-asp-net-и-веб-службы-xml","children":[]},{"level":3,"title":"Microsoft SQL Server","slug":"microsoft-sql-server","link":"#microsoft-sql-server","children":[]},{"level":3,"title":"Будущее и мечты","slug":"будущее-и-мечты","link":"#будущее-и-мечты","children":[]}]},{"level":2,"title":"Нетривиальное управление хостингом","slug":"нетривиальное-управление-хостингом","link":"#нетривиальное-управление-хостингом","children":[{"level":3,"title":"Применение управляемого кода","slug":"применение-управляемого-кода","link":"#применение-управляемого-кода","children":[]},{"level":3,"title":"Разработка надёжных хост-приложений","slug":"разработка-надежных-хост-приложении","link":"#разработка-надежных-хост-приложении","children":[]},{"level":3,"title":"Возвращение потока в хост","slug":"возвращение-потока-в-хост","link":"#возвращение-потока-в-хост","children":[]}]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch22_CLRHostingAndAppDomain.md"}');export{d as comp,p as data};
