import{_ as o,r as l,o as c,c as i,a as n,d as s,b as e,e as t}from"./app-IxoMmWNN.js";const p={},r=t(`<h1 id="гибридные-конструкции-синхронизации-потоков" tabindex="-1"><a class="header-anchor" href="#гибридные-конструкции-синхронизации-потоков"><span>Гибридные конструкции синхронизации потоков</span></a></h1><p>При отсутствии конкуренции потоков гибридные конструкции дают даже большую производительность, чем простейшие конструкции пользовательского режима.</p><h2 id="простая-гибридная-блокировка" tabindex="-1"><a class="header-anchor" href="#простая-гибридная-блокировка"><span>Простая гибридная блокировка</span></a></h2><p>В книге приводится пример простой гибридной блокировки на основе Interlocked-конструкции и AutoResetEvent.</p><h2 id="зацикливание-владение-потоком-и-рекурсия" tabindex="-1"><a class="header-anchor" href="#зацикливание-владение-потоком-и-рекурсия"><span>Зацикливание, владение потоком и рекурсия</span></a></h2><p>Так как переходы в ядро сильно снижают производительность, а потоки остаются запертыми короткое время, общую производительность можно повысить, заставив поток перед переходом в режим ядра на некоторое время зациклиться в пользовательском режиме. Если в это время блокирование, которого ждёт поток, станет возможным, переход в режим ядра не понадобится.</p><p>Некоторые варианты блокирования налагают ограничение, при котором получить право на блокировку может только поток, снимающий блокировку. В книге приводится пример гибридного блокирования, предполагающее одновременно зацикливание, владение потоком и рекурсию.</p><h2 id="гибридные-конструкции-в-fcl" tabindex="-1"><a class="header-anchor" href="#гибридные-конструкции-в-fcl"><span>Гибридные конструкции в FCL</span></a></h2><p>В FCL существует множество гибридных конструкций, которые призваны удержать потоки в пользовательском режиме, что повышает производительность.</p><h3 id="классы-manualreseteventslim-и-semaphoreslim" tabindex="-1"><a class="header-anchor" href="#классы-manualreseteventslim-и-semaphoreslim"><span>Классы ManualResetEventSlim и SemaphoreSlim</span></a></h3><p>Классы ManualResetEventSlim и SemaphoreSlim функционируют точно так же, как их аналоги режима ядра, отличаясь только зацикливанием в пользовательском режиме. Они не создают конструкций режима ядра до возникновения конкуренции.</p><h3 id="класс-monitor-и-блоки-синхронизации" tabindex="-1"><a class="header-anchor" href="#класс-monitor-и-блоки-синхронизации"><span>Класс Monitor и блоки синхронизации</span></a></h3><p>Самой популярной гибридной конструкцией является класс <code>Monitor</code>, обеспечивающий взаимоисключающее блокирование, владение потоком и рекурсией. Данная конструкция используется чаще других, так как является одной из самых старых. Для её поддержки в C# даже есть специальное ключевое слово, с ней по умолчанию умеет работать JIT-компилятор, а CLR пользуется ей от имени приложения. Однако работать с ней не просто, а получить некорректный код очень легко.</p><p>С каждым объектом в куче связан <em>блок синхронизации</em> (sync block). Этот блок содержит поля для объекта ядра, идентификатора потока-владельца, счётчика рекурсии и счётчика ожидающих потоков. Класс монитор является статическим и его методы принимают ссылки на любой объект из кучи. Управление полями эти методы осуществляют в блоке синхронизации заданного объекта.</p><p>Привязка блока синхронизации к каждому объекту в куче является очень расточительной, так как большинство объектов никогда не пользуются этим блоком. Для снижения потребления памяти, разработчики CLR применении более эффективный вариант реализации. Во время инициализации CLR выделяется массив блоков синхронизации. При создании объекта в куче инициализируется <em>индекс блока синхронизации</em> (sync block index), то есть индекс в массиве блоков синхронизации.</p><p>В момент конструирования объекта этому индексу присваивается -1. Затем при вызове метода <code>Monitor.Enter()</code> CLR обнаруживает свободный блок синхронизации и присваивает ссылку на него объекту. Метод <code>Exit()</code> проверяет наличие потоков, ожидающих блока синхронизации. Если таких потоков не обнаруживается, метод возвращает индексу значение -1, освобождая блоки синхронизации. Массив блоков синхронизации может быть увеличен, если в какой-то момент их станет недостаточно.</p><p><img src="https://github.com/kuzmin-nikita/CLR-via-CSharp/assets/80389873/1a842cc9-c4c0-45cb-b464-0001cb3a845b" alt="image"></p><p>В книге приводится пример корректного использования <code>Monitor</code>.</p><p>Так как разработчики привыкли устанавливать и снимать блокировку в одном и том же методе, в C# появился упрощённый синтаксис для этого:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">lock</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Этот код имеет эксклюзивный доступ к данным...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Что эквивалентно:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Boolean</span> lockTaken <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">try</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Исключение (например, ThreadAbortException) может здесь появиться</span>
    Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">ref</span> lockTaken<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Этот код имеет монопольный доступ к данным...</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lockTaken<span class="token punctuation">)</span>
      Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Это приводит к тому, что снятая в блоке <code>finally</code> блокировка (в ситуации, когда в блоке <code>try</code> повреждаются данные), позволит работать с повреждёнными данными другому потоку.</p><h3 id="класс-readerwriterlockslim" tabindex="-1"><a class="header-anchor" href="#класс-readerwriterlockslim"><span>Класс ReaderWriterLockSlim</span></a></h3>`,24),d={href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim?view=net-8.0",target:"_blank",rel:"noopener noreferrer"},u=n("code",null,"ReaderWriteLockSlim",-1),k=t('<ul><li>Если один поток осуществляет запись, все остальные потоки блокируются.</li><li>Если один поток читает, все остальные потоки продолжают работать; блокируются только те, которые ждут доступа на запись.</li><li>После завершения работы записывающего потока разблокируется либо один поток на запись, либо все читающий поток. При отсутствии заблокированных потоков блокировку получит следующий поток, которому это потребуется.</li><li>После завершения всех читающих потоков, разблокируется записывающий поток. При отсутствии заблокированных потоков блокировку получит следующий поток, которому это потребуется.</li></ul><h3 id="класс-onemanylock" tabindex="-1"><a class="header-anchor" href="#класс-onemanylock"><span>Класс OneManyLock</span></a></h3><p>Рихтер создал собственную конструкцию, которая работает быстрее, чем <code>ReaderWriteLockSlim</code>. Эта конструкция называется <code>OneManyLock</code>, так как она предоставляет доступ либо одному пишущему, либо многим читающим потокам. Подробнее в книге.</p><h3 id="класс-countdownevent" tabindex="-1"><a class="header-anchor" href="#класс-countdownevent"><span>Класс CountdownEvent</span></a></h3>',4),m={href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.countdownevent?view=net-8.0",target:"_blank",rel:"noopener noreferrer"},v=n("code",null,"System.Threading.CountdownEvent",-1),h=n("code",null,"ManualResetEventSlim",-1),b=n("h3",{id:"класс-barrier",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#класс-barrier"},[n("span",null,"Класс Barrier")])],-1),y={href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.barrier?view=net-8.0",target:"_blank",rel:"noopener noreferrer"},_=n("code",null,"System.Threading.Barrier",-1),f=t(`<h3 id="выводы-по-гибридным-конструкциям" tabindex="-1"><a class="header-anchor" href="#выводы-по-гибридным-конструкциям"><span>Выводы по гибридным конструкциям</span></a></h3><p>Стоит по возможности избегать кода, блокирующего потоки. При асинхронных вычислениях или операциях ввода-вывода стоит передавать данные от одного потока другому так, чтобы исключить попытку одновременного доступа. Если это невозможно, стоит использовать <code>Volatile</code> или <code>Interlocked</code>. Однако они подходят только для работы с простыми типами.</p><p>Две причины для блокирования потоков:</p><ul><li><strong>Упрощение модели программирования.</strong> Блокируя поток и жертвуя ресурсами, разработчик получает возможность писать код последовательно, без методов обратного вызова. Асинхронные функции C# предоставляют упрощённую модель программирования без необходимости блокировать потоки.</li><li><strong>Поток имеет определённое назначение.</strong></li></ul><p>Чтобы избежать блокировки потоков, не стоит мысленно связывать их с конкретными операциями. Потоки являются слишком ценным ресурсом, чтобы ограничивать их назначение. Стоит использовать пул потоков для возможности потокам решать разные задачи.</p><p>При блокировке для синхронизации потоков из разных доменов стоит использовать конструкции режима ядра. Стоит стараться избегать рекурсивных блокировок, так как они снижают производительность. Кроме того, стоит стараться не снимать блокировку в блоке <code>finally</code>, так как можно получить повреждённые данные.</p><p>В конечном счёте, для вычислительных операций или операций ввода-вывода стоит использовать асинхронные операции, так как они используют преимущества пула потоков.</p><h2 id="блокировка-с-двоинои-проверкои" tabindex="-1"><a class="header-anchor" href="#блокировка-с-двоинои-проверкои"><span>Блокировка с двойной проверкой</span></a></h2><p>К <em>блокировке с двойной проверкой</em> (double-check locking) прибегают, если нужно отложить создание <em>одиночки</em> (singletone) до тех пор, пока он не потребуется приложению - это называют <em>отложенной инициализацией</em> (lazy initialization). Это экономит время и память. Проблемы могут возникнуть если объект понадобится сразу нескольким потокам. Чтобы в результате появился только один объект, необходимо применить синхронизацию потоков. Пример реализации данной техники:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span>
<span class="token punctuation">{</span>
  <span class="token comment">// Объект s_lock требуется для обеспечения безопасности в многопоточной среде.</span>
  <span class="token comment">// Наличие этого объекта предполагает, что для создания одноэлементного объекта требуется больше ресурсов,</span>
  <span class="token comment">// чем для объекта System.Object и что эта процедура может вовсе не понадобиться.</span>
  <span class="token comment">// В противном случае проще и эффективнее получить одноэлементный объект в конструкторе класса</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name">Object</span> s_lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Это поле ссылается на один объект Singleton</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> s_value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// Закрытый конструктор не дает внешнему коду создавать экземпляры</span>
  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Код инициализации объекта Singleton</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Открытый статический метод, возвращающий объект Singleton (создавая его при необходимости)</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">Singleton</span> <span class="token function">GetSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Если объект Singleton уже создан, возвращаем его</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s_value <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s_value<span class="token punctuation">;</span>

    Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>s_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Если не создан, позволяем одному потоку сделать это</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s_value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment">// Если объекта все еще нет, создаем его</span>
      <span class="token class-name">Singleton</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// Сохраняем ссылку в переменной s_value (см. обсуждение далее)</span>
      Volatile<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s_value<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>s_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Возвращаем ссылку на объект Singleton</span>
    <span class="token keyword">return</span> s_value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Для многопоточной инициализации одиночки в FCL существует два типа <code>System.Lazy</code> и <code>System.Threading.LazyInitializer</code>.</p><h2 id="паттерн-условнои-переменнои" tabindex="-1"><a class="header-anchor" href="#паттерн-условнои-переменнои"><span>Паттерн условной переменной</span></a></h2><p>Если некий поток выполняет код при соблюдении сложного условия, то можно было бы просто организовать зацикливание этого потока с периодической проверкой условия, хотя этого не стоит делать по нескольким причинам:</p><ol><li>Пустая трата процессорного времени.</li><li>Невозможность атомарно проверить несколько переменных и условия.</li></ol><p>Решить эту проблему можно с использованием <em>паттерна условной переменной</em> (condition variable pattern):</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ConditionVariablePattern</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Object</span> m_lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token class-name">Boolean</span> m_condition <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Взаимоисключающая блокировка</span>

    <span class="token comment">// &quot;Атомарная&quot; проверка сложного условия блокирования</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>m_condition<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment">// Если условие не соблюдается, ждем, что его поменяет другой поток</span>
      Monitor<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// На время снимаем блокировку, чтобы другой поток мог ее получить</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Условие соблюдено, обрабатываем данные...</span>

    Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Снятие блокировки</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Взаимоисключающая блокировка</span>

    <span class="token comment">// Обрабатываем данные и изменяем условие...</span>
    m_condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token comment">// Monitor.Pulse(m_lock); // Будим одного ожидающего ПОСЛЕ отмены блокировки</span>
    Monitor<span class="token punctuation">.</span><span class="token function">PulseAll</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Будим всех ожидающих ПОСЛЕ отмены блокировки</span>
    Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Снятие блокировки</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="асинхронная-синхронизация" tabindex="-1"><a class="header-anchor" href="#асинхронная-синхронизация"><span>Асинхронная синхронизация</span></a></h2><p>Конструкции синхронизации потоков, использующие примитивы в режиме ядра являются не лучшей идеей. Они нужны для блокирования потоков, в то время как создание потока обходится достаточно дорого, чтобы он потом бездействовал.</p><p>Многие из проблем, решаемых гибридными конструкциями, можно успешно решить с помощью <code>Task</code>. Такой подход имеет ряд преимуществ:</p><ul><li>Задания требуют меньше памяти, быстрее создаются и уничтожаются.</li><li>Пул потоков автоматически распределяет задания между доступными процессорами.</li><li>По мере завершения заданием своего этапа, выполнявший его поток возвращается в пул, где может заняться другой работой при наличии.</li><li>Пул потоков видит все задания и может лучше их планировать, сокращая количество потоков и переключений контекста.</li></ul><p>Несколько примеров асинхронной синхронизации:</p>`,21),g={href:"https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.semaphoreslim?view=net-8.0",target:"_blank",rel:"noopener noreferrer"},w=n("code",null,"System.Threading.SemaphoreSlim",-1),S=n("code",null,"WaitAsync()",-1),x={href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.concurrentexclusiveschedulerpair?view=net-8.0",target:"_blank",rel:"noopener noreferrer"},C=n("code",null,"System.Threading.Tasks.ConcurrentExclusiveSchedulerPair",-1),M=n("li",null,[s("В .NET нет асинхронных средств с семантикой чтения/записи, но Рихтер создал "),n("code",null,"AsyncOneManyLock"),s(".")],-1),E=t('<h2 id="классы-коллекции-для-параллельного-доступа" tabindex="-1"><a class="header-anchor" href="#классы-коллекции-для-параллельного-доступа"><span>Классы коллекций для параллельного доступа</span></a></h2><p>В FCL существуют четыре потокобезопасных классов коллекций, принадлежащий пространству имён <code>System.Collections.Concurrent</code>: <code>ConcurrentQueue</code>, <code>ConcurrentStack</code>, <code>ConcurrentDictionary</code> и <code>ConcurrentBag</code>. Эти классы являются неблокирующими: при попытке извлечь несуществующий элемент поток немедленно возвращает управление, а не блокируется, ожидая появления элемента. Именно поэтому для получения используются методы <code>TryXXX()</code>, которые возвращают булево значение.</p><p>Хоть классы и являются неблокирующими, они могут использовать синхронизацию, пусть и на короткое время, необходимо для работы с элементами коллекции.</p><p>Все рассматриваемые классы обладают методом <code>GetEnumerator()</code>. Для всех классов кроме <code>ConcurrentDictionary</code> метод создаёт снимок (snapshot) и возвращает зафиксированные элементы, при этом коллекции могут поменяться.</p><p>Все классы кроме <code>ConcurrentDictionary</code> реализуют интерфейс <code>IProducerConsumerCollection</code>. Из-за этого классы могут стать блокирующими коллекциями: если коллекция заполнена, то блокируется пишущий поток, а если пуста - то читающий.</p>',5);function L(T,R){const a=l("ExternalLinkIcon");return c(),i("div",null,[r,n("p",null,[s("Если данные, которые читаются потоками, защищены взаимоисключающей блокировкой, то при попытке одновременного доступа нескольких потоков работу продолжит только один, а остальные блокируются, что ухудшает масштабируемость и снижает производительность. Хотя в случае одновременного чтение необходимости в блокировке нет, а вот при попытке записи требуется монопольный доступ. Конструкция "),n("a",d,[u,e(a)]),s(" призвана решить проблему, управляя потоками следующим образом:")]),k,n("p",null,[n("a",m,[v,e(a)]),s(" построен на основе "),h,s(" и блокирует поток до достижения внутренним счётчиком 0. Поведение этой конструкции диаметрально противоположно семафору.")]),b,n("p",null,[n("a",y,[_,e(a)]),s(" была создана для решения крайне редко возникающей проблемы, так что ею вряд ли придётся пользоваться. Она управляет группами параллельно выполняющихся потоков, обеспечивая одновременное прохождение ими всех фаз алгоритма.")]),f,n("ul",null,[n("li",null,[n("a",g,[w,e(a)]),s(" с использованием метода "),S,s(" решает проблему асинхронного ожидания получения потоком блокировки.")]),n("li",null,[n("a",x,[C,s(),e(a)]),s(" позволяет реализовать семантику записи/чтения при планировании заданий.")]),M]),E])}const B=o(p,[["render",L],["__file","ch30_hybridThreadSyncConst.html.vue"]]),I=JSON.parse('{"path":"/ru/chapters/ch30_hybridThreadSyncConst.html","title":"Гибридные конструкции синхронизации потоков","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Простая гибридная блокировка","slug":"простая-гибридная-блокировка","link":"#простая-гибридная-блокировка","children":[]},{"level":2,"title":"Зацикливание, владение потоком и рекурсия","slug":"зацикливание-владение-потоком-и-рекурсия","link":"#зацикливание-владение-потоком-и-рекурсия","children":[]},{"level":2,"title":"Гибридные конструкции в FCL","slug":"гибридные-конструкции-в-fcl","link":"#гибридные-конструкции-в-fcl","children":[{"level":3,"title":"Классы ManualResetEventSlim и SemaphoreSlim","slug":"классы-manualreseteventslim-и-semaphoreslim","link":"#классы-manualreseteventslim-и-semaphoreslim","children":[]},{"level":3,"title":"Класс Monitor и блоки синхронизации","slug":"класс-monitor-и-блоки-синхронизации","link":"#класс-monitor-и-блоки-синхронизации","children":[]},{"level":3,"title":"Класс ReaderWriterLockSlim","slug":"класс-readerwriterlockslim","link":"#класс-readerwriterlockslim","children":[]},{"level":3,"title":"Класс OneManyLock","slug":"класс-onemanylock","link":"#класс-onemanylock","children":[]},{"level":3,"title":"Класс CountdownEvent","slug":"класс-countdownevent","link":"#класс-countdownevent","children":[]},{"level":3,"title":"Класс Barrier","slug":"класс-barrier","link":"#класс-barrier","children":[]},{"level":3,"title":"Выводы по гибридным конструкциям","slug":"выводы-по-гибридным-конструкциям","link":"#выводы-по-гибридным-конструкциям","children":[]}]},{"level":2,"title":"Блокировка с двойной проверкой","slug":"блокировка-с-двоинои-проверкои","link":"#блокировка-с-двоинои-проверкои","children":[]},{"level":2,"title":"Паттерн условной переменной","slug":"паттерн-условнои-переменнои","link":"#паттерн-условнои-переменнои","children":[]},{"level":2,"title":"Асинхронная синхронизация","slug":"асинхронная-синхронизация","link":"#асинхронная-синхронизация","children":[]},{"level":2,"title":"Классы коллекций для параллельного доступа","slug":"классы-коллекции-для-параллельного-доступа","link":"#классы-коллекции-для-параллельного-доступа","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch30_hybridThreadSyncConst.md"}');export{B as comp,I as data};
