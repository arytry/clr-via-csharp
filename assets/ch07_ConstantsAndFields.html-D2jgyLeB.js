import{_ as t,o as e,c as d,e as a}from"./app-IxoMmWNN.js";const n={},s=a('<h1 id="константы-и-поля" tabindex="-1"><a class="header-anchor" href="#константы-и-поля"><span>Константы и поля</span></a></h1><h2 id="константы" tabindex="-1"><a class="header-anchor" href="#константы"><span>Константы</span></a></h2><p><em>Константа</em> (constant) - идентификатор, значение которого никогда не изменится. Значение должно определяться во время компиляции. Затем значение сохраняется в метаданных модуля. Константы могут быть только примитивных типов. Также константой может быть не примитивный тип, но с присвоением ей <code>null</code>. Константы считаются статическими членами.</p><p>Встретив в исходном коде имя константы, компилятор просматривает метаданные и вставляет в IL-код её значение. Память для констант не выделяется, потому что они хранятся в коде.</p><p>Если константа определена в другой сборке, то придётся заново компилировать обе сборки.</p><h2 id="поля" tabindex="-1"><a class="header-anchor" href="#поля"><span>Поля</span></a></h2><p><em>Поле</em> (field) - член данных, который хранит экземпляр значимого типа или ссылку на объект ссылочного типа.</p><table><thead><tr><th>Термин CLR</th><th>Термин C#</th><th>Описание</th></tr></thead><tbody><tr><td>Static</td><td>static</td><td>Поле является частью состояния типа</td></tr><tr><td>Instance</td><td>(по умолчанию)</td><td>Поле связано с экземпляром типа</td></tr><tr><td>InitOnly</td><td>readonly</td><td>Запись в поле разрешается только из конструктора</td></tr><tr><td>Volatile</td><td>volatile</td><td>Код, обращающийся к полю, не должен оптимизироваться компилятором, CLR или оборудованием с целью обеспечения безопасности потоков.</td></tr></tbody></table><p>Динамическая память для хранения поля типа выделяется в пределах объекта-типа, который создаётся при загрузке типа в домен приложения. Память для экземплярных полей выделяется при создании экземпляра.</p><p>Поля могут быть как измененяемыми, так и доступными только для чтения, инициализируемыми через конструктор. Компилятор и механизм верификации гарантируют, что ни один метод кроме конструктора не сможет записать данные в это поле. Но для изменения такого поля можно задействовать рефлексию.</p><p>Проблему с константами в разных версиях DLL можно решить через поля только для чтения, которые бы инициализировались в конструкторе, а не на этапе компиляции.</p><p>В C# есть возможность инициализации поля на месте (inline), что является сокращённой записью инициализации поля через конструктор.</p><blockquote><p>Неизменность поля ссылочного типа означает неизменность ссылки, которую этот тип содержит, а вовсе не объекта, на которую указывает ссылка.</p></blockquote>',13),l=[s];function r(c,h){return e(),d("div",null,l)}const i=t(n,[["render",r],["__file","ch07_ConstantsAndFields.html.vue"]]),p=JSON.parse('{"path":"/ru/chapters/ch07_ConstantsAndFields.html","title":"Константы и поля","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Константы","slug":"константы","link":"#константы","children":[]},{"level":2,"title":"Поля","slug":"поля","link":"#поля","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch07_ConstantsAndFields.md"}');export{i as comp,p as data};
