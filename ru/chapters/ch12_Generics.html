<!doctype html>
<html lang="ru-RU">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches
      if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
        document.documentElement.classList.toggle('dark', true)
      }
    </script>
    <link rel="icon" href="/assets/img/favicon.ico"><title>Обобщения | CLR via C#</title><meta name="description" content="CLR via C# Четвертое издание">
    <link rel="preload" href="/clr-via-csharp/assets/style-FaCSB-_p.css" as="style"><link rel="stylesheet" href="/clr-via-csharp/assets/style-FaCSB-_p.css">
    <link rel="modulepreload" href="/clr-via-csharp/assets/app-IxoMmWNN.js"><link rel="modulepreload" href="/clr-via-csharp/assets/ch12_Generics.html-D0mGmkov.js">
    <link rel="prefetch" href="/clr-via-csharp/assets/index.html-ZkH5qKEm.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-BvaI8qfN.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-D-7172Jl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BLQSYEbL.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-Cmb5tXx5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-C65m3L6w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-MhrBc603.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BExRN6IU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-Cwf82xZd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-U9jK40Ei.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CUDFuVYa.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-0oTJyJmn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-LLUaep7w.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-Bi9j89Ya.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-Dbx7WK6o.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-DsmoFQbF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-noMBAT3f.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-MFb5H9zK.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-ZDLMr6H2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DYgFyOwD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-BtysPki2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CDUugoVg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BWeh_aT3.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-CfeNN69i.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-D16BElAb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-DK1leolo.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-CQ2ygEuE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-C3cvw10V.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-CMPdATok.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-CTieDbCf.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CJcp4OCy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-CFsstSQQ.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-beZI77Lv.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-Bi67Yt5h.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-dvExR8Gk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/index.html-GDcN_xMH.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BwKxRLwh.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-BMQPeoI2.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-27zHcXlW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-CVDf2x4Y.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-DkaxxntM.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-BGwRCWdf.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-D2jgyLeB.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CcZqtO9s.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-Cgf_mCwx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-CO8XAMmW.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-DZ5a5JQg.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-BGdd7LBY.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-DExRFCv1.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BiTZ-5od.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-Dsjpqw47.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-DWEP33D9.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-DtaR-VvP.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-CvrkASkk.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BuN-nGuz.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-f0AOnmUF.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-C4pcwqj-.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-CHZCU__5.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-emd0r8wc.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-BmMk3Oqy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-DDuBq2h_.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DXXfHTUn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-CwFR1TuA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-Bjaf8DNA.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-D2MW45gx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/Postscript.html-Bpkc--tR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch01_TheCLRSExecutionMode.html-BPnkWvJ8.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch02_Building.html-q0yDwRpt.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch03_SharedAssemblies.html-BjqQ7sdC.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch04_TypeFundamentals.html-BIIy8leD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch05_PrimitiveRefValType.html-BOo-9fso.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch06_TypeAndMemberBasics.html-DzDrvZ87.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch07_ConstantsAndFields.html-CASmG777.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch08_Methods.html-CEM163Qb.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch09_Parameters.html-BkR6SOXn.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch10_Properties.html-sfPfXudR.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch11_Events.html-LJfkVvEp.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch12_Generics.html-CSXiWNpq.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch13_Interfaces.html-CBasocgy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch14_CharStringText.html-o4yS52Dy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch15_EnumeratedTypes.html-BZtqvWYE.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch16_Arrays.html-CGp-_Jrw.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch17_Delegates.html-tcKP_pXy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch18_CustomAttributes.html-B6RvN9hy.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch19_NullableValueTypes.html-BkMiV6yx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch20_ExceptionsAndStateManae.html-BsTwrSmr.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch21_ManagedHeapGarbage.html-BDn6rSrD.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch22_CLRHostingAndAppDomain.html-Bi_35IQj.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch23_AssemblyLoaingReflection.html-stJPEo8t.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch24_RuntimeSerialization.html-BexV0ImS.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch25_WinRTComponents.html-Cw_fsfmx.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch26_ThreadBasics.html-QnhhtSZl.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch27_ComputeBoundAsync.html-DNJcQUkI.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch28_IOBoundAsyncOperations.html-BAwtWkjU.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch29_PrimitiveThreadSyncConstructs.html-5-bQNQmT.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/ch30_hybridThreadSyncConst.html-DKmbpj4c.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/foreword.html-GASyXvmd.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/introduction.html-D6bO62ut.js" as="script"><link rel="prefetch" href="/clr-via-csharp/assets/404.html-5gOqppNC.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/clr-via-csharp/ru/"><img class="logo" src="/clr-via-csharp/assets/images/cover.jpg" alt="CLR via C#"><span class="site-name can-hide" aria-hidden="true">CLR via C#</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/chapters/ch12_Generics.html" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items" aria-label="site navigation"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Выберите язык</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="route-link" href="/clr-via-csharp/chapters/ch12_Generics.html" aria-label="简体中文"><!--[--><!--[--><!--]--> 简体中文 <!--[--><!--]--><!--]--></a></li><li class="navbar-dropdown-item"><a class="route-link route-link-active" href="/clr-via-csharp/" aria-label="Русский"><!--[--><!--[--><!--]--> Русский <!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/arytry/clr-via-csharp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch01_TheCLRSExecutionMode.html" aria-label="Модель выполнения кода в среде CLR"><!--[--><!--[--><!--]--> Модель выполнения кода в среде CLR <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch02_Building.html" aria-label="Компоновка, упаковка, развёртывание и администрирование приложений и типов"><!--[--><!--[--><!--]--> Компоновка, упаковка, развёртывание и администрирование приложений и типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch03_SharedAssemblies.html" aria-label="Совместно используемые сборки и сборки со строгим именем"><!--[--><!--[--><!--]--> Совместно используемые сборки и сборки со строгим именем <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch04_TypeFundamentals.html" aria-label="Основы типов"><!--[--><!--[--><!--]--> Основы типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch05_PrimitiveRefValType.html" aria-label="Примитивные, ссылочные и значимые типы"><!--[--><!--[--><!--]--> Примитивные, ссылочные и значимые типы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch06_TypeAndMemberBasics.html" aria-label="Основные сведения о членах и типах"><!--[--><!--[--><!--]--> Основные сведения о членах и типах <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch07_ConstantsAndFields.html" aria-label="Константы и поля"><!--[--><!--[--><!--]--> Константы и поля <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch08_Methods.html" aria-label="Методы"><!--[--><!--[--><!--]--> Методы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch09_Parameters.html" aria-label="Параметры"><!--[--><!--[--><!--]--> Параметры <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch10_Properties.html" aria-label="Свойства"><!--[--><!--[--><!--]--> Свойства <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch11_Events.html" aria-label="События"><!--[--><!--[--><!--]--> События <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active sidebar-item sidebar-heading active" href="/clr-via-csharp/ru/chapters/ch12_Generics.html" aria-label="Обобщения"><!--[--><!--[--><!--]--> Обобщения <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#обобщения-в-библиотеке-fcl" aria-label="Обобщения в библиотеке FCL"><!--[--><!--[--><!--]--> Обобщения в библиотеке FCL <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#инфраструктура-обобщении" aria-label="Инфраструктура обобщений"><!--[--><!--[--><!--]--> Инфраструктура обобщений <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#открытые-и-закрытые-типы" aria-label="Открытые и закрытые типы"><!--[--><!--[--><!--]--> Открытые и закрытые типы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#обобщенные-типы-и-наследование" aria-label="Обобщённые типы и наследование"><!--[--><!--[--><!--]--> Обобщённые типы и наследование <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#идентификация-обобщенных-типов" aria-label="Идентификация обобщённых типов"><!--[--><!--[--><!--]--> Идентификация обобщённых типов <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#разрастание-кода" aria-label="Разрастание кода"><!--[--><!--[--><!--]--> Разрастание кода <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#обобщенные-интерфеисы" aria-label="Обобщённые интерфейсы"><!--[--><!--[--><!--]--> Обобщённые интерфейсы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#обобщенные-делегаты" aria-label="Обобщённые делегаты"><!--[--><!--[--><!--]--> Обобщённые делегаты <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#контравариантные-и-ковариантные-аргументы-типы-в-делегатах-и-интерфеисах" aria-label="Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах"><!--[--><!--[--><!--]--> Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#обобщенные-методы" aria-label="Обобщённые методы"><!--[--><!--[--><!--]--> Обобщённые методы <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#обобщенные-методы-и-выведение-типов" aria-label="Обобщённые методы и выведение типов"><!--[--><!--[--><!--]--> Обобщённые методы и выведение типов <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link sidebar-item" href="#обобщения-и-другие-члены" aria-label="Обобщения и другие члены"><!--[--><!--[--><!--]--> Обобщения и другие члены <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#верификация-и-ограничения" aria-label="Верификация и ограничения"><!--[--><!--[--><!--]--> Верификация и ограничения <!--[--><!--]--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a class="route-link sidebar-item" href="#основные-ограничения" aria-label="Основные ограничения"><!--[--><!--[--><!--]--> Основные ограничения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#дополнительные-ограничения" aria-label="Дополнительные ограничения"><!--[--><!--[--><!--]--> Дополнительные ограничения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#ограничения-конструктора" aria-label="Ограничения конструктора"><!--[--><!--[--><!--]--> Ограничения конструктора <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item" href="#другие-проблемы-верификации" aria-label="Другие проблемы верификации"><!--[--><!--[--><!--]--> Другие проблемы верификации <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch13_Interfaces.html" aria-label="Интерфейсы"><!--[--><!--[--><!--]--> Интерфейсы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch14_CharStringText.html" aria-label="Символы, строки и обработка текста"><!--[--><!--[--><!--]--> Символы, строки и обработка текста <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch15_EnumeratedTypes.html" aria-label="Перечислимые типы и битовые флаги"><!--[--><!--[--><!--]--> Перечислимые типы и битовые флаги <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch16_Arrays.html" aria-label="Массивы"><!--[--><!--[--><!--]--> Массивы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch17_Delegates.html" aria-label="Делегаты"><!--[--><!--[--><!--]--> Делегаты <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch18_CustomAttributes.html" aria-label="Настраиваемые атрибуты"><!--[--><!--[--><!--]--> Настраиваемые атрибуты <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch19_NullableValueTypes.html" aria-label="Null-совместимые значимые типы"><!--[--><!--[--><!--]--> Null-совместимые значимые типы <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch20_ExceptionsAndStateManae.html" aria-label="Исключения и управление состоянием"><!--[--><!--[--><!--]--> Исключения и управление состоянием <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch21_ManagedHeapGarbage.html" aria-label="Автоматическое управление памятью (сборка мусора)"><!--[--><!--[--><!--]--> Автоматическое управление памятью (сборка мусора) <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch22_CLRHostingAndAppDomain.html" aria-label="Хостинг CLR и домены приложений"><!--[--><!--[--><!--]--> Хостинг CLR и домены приложений <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch23_AssemblyLoaingReflection.html" aria-label="Загрузка сборок и отражение"><!--[--><!--[--><!--]--> Загрузка сборок и отражение <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch24_RuntimeSerialization.html" aria-label="Сериализация"><!--[--><!--[--><!--]--> Сериализация <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch25_WinRTComponents.html" aria-label="Взаимодействие с компонентами WinRT"><!--[--><!--[--><!--]--> Взаимодействие с компонентами WinRT <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch26_ThreadBasics.html" aria-label="Потоки исполнения"><!--[--><!--[--><!--]--> Потоки исполнения <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch27_ComputeBoundAsync.html" aria-label="Асинхронные вычислительные операции"><!--[--><!--[--><!--]--> Асинхронные вычислительные операции <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch28_IOBoundAsyncOperations.html" aria-label="Асинхронные операции ввода-вывода"><!--[--><!--[--><!--]--> Асинхронные операции ввода-вывода <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch29_PrimitiveThreadSyncConstructs.html" aria-label="Примитивные конструкции синхронизации потоков"><!--[--><!--[--><!--]--> Примитивные конструкции синхронизации потоков <!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link sidebar-item sidebar-heading" href="/clr-via-csharp/ru/chapters/ch30_hybridThreadSyncConst.html" aria-label="Гибридные конструкции синхронизации потоков"><!--[--><!--[--><!--]--> Гибридные конструкции синхронизации потоков <!--[--><!--]--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="обобщения" tabindex="-1"><a class="header-anchor" href="#обобщения"><span>Обобщения</span></a></h1><p>Одно из ключевых преимуществ ООП - возможность многократного использования кода за счёт наследования. <em>Обобщения</em> (generics) - ещё один механизм, поддерживаемый CLR и языками программирования для другой разновидности многократного использования кода - многократного использования алгоритмов. Разработчик описывает алгоритм, но не указывает тип данных, что позволяет алгоритму работать с несколькими типами данных.</p><p>Большинство алгоритмов инкапсулировано в типе. CLR поддерживает создание как обобщённых ссылочных, так и обобщённых значимых типов, но не поддерживает обобщённые перечислимые типы. Кроме того, можно создавать обобщённые интерфейсы и делегаты, а также обобщённые методы, определённые в ссылочным и значимом типах или в интерфейсах.</p><p>При определение обобщённого типа или метода переменные, указанные вместо типа (например, <code>T</code>), называются <em>параметрами типа</em> (type parameters). <code>T</code> — это имя переменной, которое применяется в исходном коде везде, где используется соответствующий тип.</p><p>В рекомендация Microsoft указано, что тип должен называться T или начинаться с T (например, TKey или TValue).</p><p>При использовании обобщённого типа данных или метода, разработчик передаёт необходимый ему тип в качестве <em>аргумента-типа</em> (type arguments).</p><p>Главные преимущества обобщений для разработчиков:</p><ul><li><strong>Защита исходного кода.</strong> Разработчику, использующему обобщённый алгоритм, не нужен доступ к исходному коду.</li><li><strong>Безопасность типов.</strong> Когда обобщение применяется с конкретным типом, компилятор и CLR понимают это и следят за тем, чтобы алгоритм был типобезопасным. Иначе это приведёт к ошибке компиляции или во время выполнения.</li><li><strong>Более простой и понятный код.</strong> В исходном коде требуется меньше операций приведения, так как тип разрешается на этапе компиляции.</li><li><strong>Повышение производительности.</strong> До появления обобщений подобный механизм реализовывался через тип <code>object</code>. Это вызывало необходимость упаковки и распаковки, а также выделения памяти в куче для значимых типов и вызов сборщика мусора. Появление обобщений оптимизировало данную работу.</li></ul><h2 id="обобщения-в-библиотеке-fcl" tabindex="-1"><a class="header-anchor" href="#обобщения-в-библиотеке-fcl"><span>Обобщения в библиотеке FCL</span></a></h2><p>Обобщения применяются к классам коллекций и в FCL определено несколько таких обобщённых классов. Также имеются безопасные в отношении потоков классы коллекций. Microsoft рекомендует использовать именно обобщённые классы коллекций по нескольких причинам:</p><ul><li>Необобщённые классы коллекций не обеспечивают безопасность типов, простоту и понятность кода, а также повышение производительности.</li><li>У обобщённых классов лучше объектная модель (например, меньше виртуальных методов, что повышает производительность).</li></ul><p>Классы коллекций реализуют множество интерфейсов, а объекты, добавляемые в коллекции, могут реализовывать интерфейсы, используемые классами коллекций для таких операций, как сортировка и поиск.</p><p>Новые обобщённые интерфейсы не заменяют необобщённые, а дополняют их с целью обеспечить обратную совместимость.</p><h2 id="инфраструктура-обобщении" tabindex="-1"><a class="header-anchor" href="#инфраструктура-обобщении"><span>Инфраструктура обобщений</span></a></h2><p>Поддержка обобщений была добавлена в CLR 2.0. Для поддержания работы обобщений было сделано следующее:</p><ul><li>Созданы новые IL-команды, работающие с аргументами типа.</li><li>Изменён формат существующих таблиц метаданных для выражения имён типов и методов с обобщёнными параметрами.</li><li>Обновлены многие языки программирования, чтобы добавить поддержку обобщений.</li><li>Изменены компиляторы для генерации новых IL-команд и изменённого формата метаданных.</li><li>Изменён JIT-компилятор, чтобы он обрабатывал новые IL-команды.</li><li>Созданы новые члены рефлексии.</li><li>Определены новые члены, предоставлявшие информацию рефлексии, чтобы разработчики могли создавать определения обобщённых типов и методов во время исполнения.</li><li>Изменён отладчик, чтобы он поддерживал обобщение.</li><li>Изменена функция IntelliSense для отображения конкретных прототипов членов при использовании обобщённого типа.</li></ul><h3 id="открытые-и-закрытые-типы" tabindex="-1"><a class="header-anchor" href="#открытые-и-закрытые-типы"><span>Открытые и закрытые типы</span></a></h3><p>Для каждого типа, применяемого в приложении, CLR создаёт внутреннюю структуру данных. Эти структуры называются <em>объектами-типами</em> (type objects). Обобщённый тип также считается типом, и для него CLR также создаёт объект-тип. Это справедливо для классов, структур, интерфейсов и делегатов. Тип с обобщёнными параметрами-типами называют <em>открытым типом</em> (open types), а в CLR запрещено конструировании экземпляров обобщённых типов (как и экземпляров интерфейсов).</p><p>При ссылке на обобщённый тип в коде можно определить набор обобщённых аргументов типа. Если всем аргументам определённого типа передаются действительные типы данных, то он становится <em>закрытым типом</em> (closed type). CLR разрешает создание экземпляров закрытых типов. Тем не менее в коде, ссылающемся на обобщённый тип, можно не определять все обобщённые аргументы типа. Тогда в CLR создастся объект открытого типа, экземпляры которого создавать нельзя.</p><p>Имена обобщённых типов заканчиваются одинарной кавычкой (`), за которой следует число, означающее <em>арность</em> (arity) типа, то есть число необходимых для него параметров типа.</p><p>CLR размещает статические поля типа в объекте-типе. Следовательно, каждый закрытый тип имеет свои статические поля. Иначе говоря, статические поля различных обобщённых типов не будут использоваться вместе, потому что у каждого объекта закрытого типа есть свои статические поля. Статический конструктор в обобщённом типе выполняется единожды для каждого закрытого типа.</p><p>В CLR существует механизм <em>ограничений</em> (constraints), предлагающий более удачный инструмент определения обобщённого типа с указанием допустимых для него аргументов типа.</p><h3 id="обобщенные-типы-и-наследование" tabindex="-1"><a class="header-anchor" href="#обобщенные-типы-и-наследование"><span>Обобщённые типы и наследование</span></a></h3><p>Обобщённый тип может быть производным от других типов. При использовании обобщённого типа с указанием аргументов типа в CLR определяется новый объект-тип, производный от того же объекта, что и обобщённый тип. Понимание того, что определение аргументов типа не имеет ничего общего с наследованием, помогает разобраться, какие приведения типов допустимы.</p><p>Например, если разработчик хочет создать связный список с разными типами данных в узлах, он может использовать <code>object</code>, однако это не безопасно по типам и не производительно из-за упаковки. В данном случае лучше определить базовый тип как необобщённый и наследовать обобщённый типы от него.</p><h3 id="идентификация-обобщенных-типов" tabindex="-1"><a class="header-anchor" href="#идентификация-обобщенных-типов"><span>Идентификация обобщённых типов</span></a></h3><p>Синтаксис обобщённых типов часто приводит разработчиков в замешательство, так как в исходном коде появляется много знаков &lt; и &gt;, что затрудняет чтение. Для упрощения синтаксиса можно создать новый необобщённый тип класса, производный от обобщённого и определяющий все необходимые аргументы типа.</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">// Если нужно упростить данный код</span>
<span class="token class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">&gt;</span></span> dt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// То можно определить такой класс</span>
<span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">DateTimeList</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">List<span class="token punctuation">&lt;</span>DateTime<span class="token punctuation">&gt;</span></span></span>
<span class="token punctuation">{</span>
  <span class="token comment">// Здесь никакой код добавлять не нужно!</span>
<span class="token punctuation">}</span>

<span class="token comment">// И тогда вызывать его будет проще</span>
<span class="token class-name">DateTimeList</span> dt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DateTimeList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Этот вариант удобен, однако его ни в коем случае нельзя использовать только затем, чтобы упростить чтение исходного кода. Причина проста: пропадает тождественность и эквивалентность типов. Нельзя передать <code>List&lt;DateTime&gt;</code> туда, где определён <code>DateTimeList</code>, потому что его нельзя будет привести. А наоборот можно. И всё это вызывает путаницу.</p><p>К счастью, это можно обойти с использованием ссылки на обобщённый закрытый тип. Для этого необходимо определить псевдоним данного типа в начале файла с использованием директивы <code>using</code>.</p><h3 id="разрастание-кода" tabindex="-1"><a class="header-anchor" href="#разрастание-кода"><span>Разрастание кода</span></a></h3><p>При JIT-компиляции обобщённого метода CLR подставляет в IL-код метода указанные аргументы-типы, а затем создаёт машинный код для данного метода, работающий с конкретными данными. Это и является одной из основных функций обобщения. Но в таком подходе есть и недостаток, так как машинный код генерируется для каждого сочетания &quot;метод + тип&quot;, что приводит к <em>разрастанию кода</em> (code explosion). В итоге рабочий набор приложения существенно увеличивается, снижая производительность.</p><p>В CLR есть несколько механизмов оптимизации, призванных предотвратить разрастание кода. Во-первых, если метод вызывается для конкретного типа и позже он опять вызывается с тем же аргументом типа, то код для такого сочетания генерируется единожды, даже если тип используется в разных сборках (но в одном домене приложений).</p><p>Кроме того, CLR считает все аргументы ссылочного типа тождественными, что опять же обеспечивает совместное использование кода. По сути, для всех ссылочных типов используется одинаковый код. CLR выполняет эту оптимизацию потому, что все аргументы и переменные ссылочного типа являются всего лишь указателями на объекты в куче, а все операции с указателями выполняются одинаково.</p><p>Но если аргументы типа относятся к значимому типу, CLR должна сгенерировать машинный код именно для этого значимого типа. Это объясняется тем, что у значимых типов может быть разный размер. И даже если у типов будет одинаковый размер, CLR всё равно не сможет использовать для них единый код, так как для обработки этих значений могут применяться разные машинные команды.</p><h2 id="обобщенные-интерфеисы" tabindex="-1"><a class="header-anchor" href="#обобщенные-интерфеисы"><span>Обобщённые интерфейсы</span></a></h2><p>Основное преимущество обобщений - способность определять обобщённые ссылочные и значимые типы. Но для CLR также важна поддержка обобщённых интерфейсов. Без них любая попытка работы со значимым типом через необобщённый интерфейс всегда будет приводить к необходимости упаковки и потере типобезопасности в процессе компиляции, что сильно бы сузило область применения обобщённых типов. Ссылочный и значимый типы реализуют обобщённый интерфейс путём задания аргументов-типов, или же любой тип реализует обобщённый интерфейс без указания аргументов-типов.</p><h2 id="обобщенные-делегаты" tabindex="-1"><a class="header-anchor" href="#обобщенные-делегаты"><span>Обобщённые делегаты</span></a></h2><p>Поддержка обобщённых делегатов позволяет передавать методам обратного вызова любые типы объектов, обеспечивая при этом безопасность типов. Более того, благодаря обобщённым делегатам экземпляры значимого типа могут передаваться методам обратного вызова без упаковки. Делегат — это определение класса с помощью четырёх методов: конструктора и методов <code>Invoke</code>, <code>BeginInvoke</code> и <code>EndInvoke</code>. При определении типа делегата с параметрами типа, компилятор задаёт методы класса делегата, а параметры типа применяются ко всем методам, параметры и возвращаемые значения которых относятся к указанному параметру типа.</p><p>Там, где это возможно, рекомендуется использовать обобщённые делегаты <code>Action&lt;&gt;</code> и <code>Func&lt;&gt;</code> из библиотеки FCL.</p><h3 id="контравариантные-и-ковариантные-аргументы-типы-в-делегатах-и-интерфеисах" tabindex="-1"><a class="header-anchor" href="#контравариантные-и-ковариантные-аргументы-типы-в-делегатах-и-интерфеисах"><span>Контравариантные и ковариантные аргументы-типы в делегатах и интерфейсах</span></a></h3><p>Каждый из параметров-типов обобщённого делегата должен быть помечен как ковариантный или контравариантный. Это позволяет осуществлять приведение типа переменной обобщённого делегата к <em>тому же типу делегата</em> с другим параметром-типом. Параметры могут быть:</p><ul><li><strong>Инвариантными.</strong> Параметр-тип не может изменяться.</li><li><strong>Контравариантными.</strong> Параметр-тип может быть преобразован от класса к классу, производному от него. В C# контравариантный тип помечается ключевым словом <code>in</code>. Контравариантный параметр-тип может появляться только во входной позиции, например, в качестве аргументов метода.</li><li><strong>Ковариантными.</strong> Аргумент-тип может быть преобразован от класса к одному из его базовых классов. В C# ковариантный тип помечается ключевым словом <code>out</code>. Ковариантный параметр обобщённого типа может появляться только в выходной позиции, например, в качестве возвращаемого методом значения.</li></ul><p>Вариантность действует только в том случае, если компилятор может установить возможность преобразования ссылок между типа. Вариантность неприменима для значимых типов из-за необходимости упаковки. Вариантность также недопустима для параметра-типа, если он передаётся по ссылке.</p><p>При использовании обобщённых делегатов стоит использовать вариантность везде, где это возможно, так как это приводит к большему количеству возможных сценариев и не приводит к нежелательным последствиям. Инвариантность применима также и к параметрам-типам интерфейсов.</p><h2 id="обобщенные-методы" tabindex="-1"><a class="header-anchor" href="#обобщенные-методы"><span>Обобщённые методы</span></a></h2><p>При определении обобщённых типов или интерфейсов, определённые в них методы также могут быть обобщёнными и использовать параметр-тип типа. Параметр-тип можно использовать для параметров метода, возвращаемого значения, а также локальных переменных внутри метода. Кроме того, методы могут иметь собственные параметры-типы.</p><h3 id="обобщенные-методы-и-выведение-типов" tabindex="-1"><a class="header-anchor" href="#обобщенные-методы-и-выведение-типов"><span>Обобщённые методы и выведение типов</span></a></h3><p>Синтаксис обобщений в C# может приводить разработчиков в замешательство, поэтому с целью упростить создание, чтение и работу с кодом компилятор предлагает <em>логическое выведение типов</em> (type inference) при вызове обобщённых методов. Это значит, что компилятор пытается определить (<em>логически вывести</em>) тип, который будет использоваться при вызове обобщённого метода. При выполнении логического выведения используется тип переменной, а не тип объекта, на который ссылается эта переменная.</p><p>Тип может определять таким образом несколько методов таким образом, что один из них будет принимать конкретный тип данных, а другой - обобщённый параметр тип. В этом случае компилятор отдаёт предпочтение явному методу.</p><h2 id="обобщения-и-другие-члены" tabindex="-1"><a class="header-anchor" href="#обобщения-и-другие-члены"><span>Обобщения и другие члены</span></a></h2><p>В C# у свойств, индексаторов, событий, операторных методов и деструкторов не может быть параметров-типов. Однако их можно определить в обобщённом типе, чтобы в их коде использовать параметры-типы этого типа.</p><h2 id="верификация-и-ограничения" tabindex="-1"><a class="header-anchor" href="#верификация-и-ограничения"><span>Верификация и ограничения</span></a></h2><p>В процессе компиляции обобщённого кода компилятор анализирует его, чтобы убедиться, что он сможет работать с любыми типами данных - существующими и теми, которые будут определены в будущем. По умолчанию параметр-типа ограничен <code>System.Object</code> и ему доступны операции только этого типа. Для того, чтобы расширить возможный функционал, CLR и компиляторы поддерживают механизм <em>ограничений</em> (constraints). Ограничение сужает перечень типов, которые можно передать в обобщённом тип, и расширяет возможности по работе с этими типами. Создать ограничение можно с использованием маркера <code>where</code>.</p><p>При создании закрытого типа компилятор должен проверить, что переданный аргумент-тип удовлетворяет ограничениям, и выдать ошибку в случае несовпадения типов.</p><p>Ограничения можно применять к параметрам типов как в обобщённых типах, так и в обобщённых методах. CLR не поддерживает перегрузку по именам параметров или по именам ограничений, а только по арности метода.</p><p>При переопределении виртуального обобщённого метода в переопределяющем методе должна совпадать арность, а также он наследует все ограничения. Собственно, переопределяемый метод не вправе задавать ограничения для своих параметров-типов, но может их переименовывать параметры-типы. Аналогично при реализации обобщённого метода интерфейса.</p><h3 id="основные-ограничения" tabindex="-1"><a class="header-anchor" href="#основные-ограничения"><span>Основные ограничения</span></a></h3><p>В параметре-типе можно задать не более одного основного ограничения. Основным ограничением может быть ссылочный тип, указывающий на незапечатанный класс, кроме <code>System.Object</code>, <code>System.Array</code>, <code>System.Delegate</code>, <code>System.MulticastDelegate</code>, <code>System.ValueType</code>, <code>System.Enum</code> и <code>System.Void</code>. При задании ограничения ссылочного типа для компилятора гарантируется, что заданный аргумент-тип будет относиться либо у указанному типу, либо к производному от него. Если основное ограничение не задано, то установлен <code>System.Object</code>.</p><p>Есть два особых ограничения: <code>class</code> и <code>struct</code>. Данные ограничения говорят компилятору, что аргумент-тип, будет, соответственно ссылочным или значимым типом.</p><h3 id="дополнительные-ограничения" tabindex="-1"><a class="header-anchor" href="#дополнительные-ограничения"><span>Дополнительные ограничения</span></a></h3><p>Для параметра-типа могут быть заданы нуль и более дополнительных ограничений. В качестве дополнительного ограничения можно указать один или несколько интерфейсу, что сообщает компилятору о том, что аргумент-тип должен реализовывать все эти интерфейсы.</p><p>Другой тип дополнительных ограничений называют <em>ограничением параметра-типа</em> (type parameter constraint). Например, можно сообщить компилятору, что один из параметров-типов должен быть совместим с другим (был наследником или реализовывал интерфейс).</p><h3 id="ограничения-конструктора" tabindex="-1"><a class="header-anchor" href="#ограничения-конструктора"><span>Ограничения конструктора</span></a></h3><p>Для параметра-типа можно задать не более одного ограничения на то, чтобы он был неабстрактным типом с открытым конструктором без параметров.</p><h3 id="другие-проблемы-верификации" tabindex="-1"><a class="header-anchor" href="#другие-проблемы-верификации"><span>Другие проблемы верификации</span></a></h3><p>В оставшейся части приводятся несколько конструкций, которые из-за проблем с верификацией ведут себя непредсказуемо, и показано, как с помощью ограничений сделать их верифицируемыми.</p><h4 id="приведение-переменнои-обобщенного-типа" tabindex="-1"><a class="header-anchor" href="#приведение-переменнои-обобщенного-типа"><span>Приведение переменной обобщённого типа</span></a></h4><p>Приведение переменной обобщённого типа к другому типу допускается только в случае, если она приводится к типу, совместимому с ограничением. Для всех типов это можно сделать через <code>object</code>, однако можно получить <code>InvalidCastException</code>. Для ссылочных типов можно использовать оператор <code>as</code>.</p><h4 id="присваивание-переменнои-обобщенного-типа-значения-по-умолчанию" tabindex="-1"><a class="header-anchor" href="#присваивание-переменнои-обобщенного-типа-значения-по-умолчанию"><span>Присваивание переменной обобщённого типа значения по умолчанию</span></a></h4><p>Присваивать <code>null</code> не всегда возможно, так как не все параметры-типы поддерживают это значение. Данную проблему можно обойти с применением ключевого слова <code>default</code>.</p><h4 id="сравнение-переменнои-обобщенного-типа-с-null" tabindex="-1"><a class="header-anchor" href="#сравнение-переменнои-обобщенного-типа-с-null"><span>Сравнение переменной обобщённого типа с null</span></a></h4><p>Сравнивать с <code>null</code> можно, однако для значимого типа есть пара вариантов:</p><ul><li>При применении оператора <code>==</code> тело <code>if</code> не будет скомпилировано в машинный код, так как никогда не вызовется.</li><li>При применении оператора <code>!=</code> не будет сгенерирован код для инструкции <code>if</code>, потому что оно всегда истинно, но тело будет скомпилировано.</li></ul><p>Кстати, при применении ограничения <code>struct</code> данный код вызовет ошибку компиляции.</p><h4 id="сравнение-двух-переменных-обобщенного-типа" tabindex="-1"><a class="header-anchor" href="#сравнение-двух-переменных-обобщенного-типа"><span>Сравнение двух переменных обобщённого типа</span></a></h4><p>Сравнение двух переменных через <code>==</code> доступно, если оба операнда являются ссылочными.</p><h4 id="использование-переменных-обобщенного-типа-в-качестве-операндов" tabindex="-1"><a class="header-anchor" href="#использование-переменных-обобщенного-типа-в-качестве-операндов"><span>Использование переменных обобщённого типа в качестве операндов</span></a></h4><p>На данный момент нет возможности использовать операторы в обобщённом методе, так как он не знает их тип и нельзя поставить ограничение на использование, например, примитивного типа.</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="external-link label" href="https://github.com/arytry/clr-via-csharp/edit/main/docs/ru/chapters/ch12_Generics.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--[--><svg class="icon" viewBox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--><!--]--></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link prev" href="/clr-via-csharp/ru/chapters/ch11_Events.html" aria-label="События"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span>События</span></div><!--]--></a><a class="route-link next" href="/clr-via-csharp/ru/chapters/ch13_Interfaces.html" aria-label="Интерфейсы"><!--[--><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>Интерфейсы</span></div><!--]--></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/clr-via-csharp/assets/app-IxoMmWNN.js" defer></script>
  </body>
</html>
