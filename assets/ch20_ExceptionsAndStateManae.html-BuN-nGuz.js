import{_ as n,o as a,c as s,e}from"./app-IxoMmWNN.js";const c={},l=e(`<h1 id="исключения-и-управление-состоянием" tabindex="-1"><a class="header-anchor" href="#исключения-и-управление-состоянием"><span>Исключения и управление состоянием</span></a></h1><p>Процесс <em>обработки исключений</em> (exception handling) состоит из нескольких шагов. Сначала нужно определить, что именно считать ошибкой. Затем нужно выяснить, как возникает ошибка и как от неё избавиться. Скорее всего, в момент ошибки код находится в каком-то промежуточном состоянии, и его потребуется вернуть в состояние до момента возникновения ошибки.</p><h2 id="определение-исключения" tabindex="-1"><a class="header-anchor" href="#определение-исключения"><span>Определение &quot;исключения&quot;</span></a></h2><p>Конструируя тип, разработчики заранее пытаются представить, в каких ситуациях тип будет использоваться. Члены типа определяют допустимые действия с типом и его экземплярами. Если член не может решить поставленную перед ним задачу, он должен выбросить исключение. Не все члены типа умеют возвращать код ошибки, но они должны каким-то образом сообщать о её наличии. В .NET и всех поддерживаемых этой платформой языках существует специальный механизм обработки исключений.</p><h2 id="механика-обработки-исключении" tabindex="-1"><a class="header-anchor" href="#механика-обработки-исключении"><span>Механика обработки исключений</span></a></h2><p>В основе обработки исключений в .NET лежит <em>структурная обработка исключений</em> (Structured Exception Handling, SEH).</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">try</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Код, требующий корректного восстановления или очистки ресурсов</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvalidOperationException</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Код восстановления работоспособности после исключения InvalidOperationException</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
   <span class="token comment">// Код восстановления работоспособности после исключения IOException</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Код восстановления работоспособности после остальных исключений.</span>
    <span class="token comment">// После перехвата исключений их обычно генерируют повторно</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Здесь находится код, выполняющий очистку ресурсов после операций, начатых в блоке try.</span>
    <span class="token comment">// Этот код выполняется ВСЕГДА вне зависимости от наличия исключения</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Код, следующий за блоком finally, выполняется, если в блоке try не генерировалось исключение</span>
  <span class="token comment">// или если исключение было перехвачено блоком catch, а новое не генерировалось</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>В большинстве случаев используются комбинации <code>try-catch</code> или <code>try-finally</code>.</p><h3 id="блок-try" tabindex="-1"><a class="header-anchor" href="#блок-try"><span>Блок try</span></a></h3><p>В данный блок помещается код, требующий очистки ресурсов (прим. Комбинацией <code>try-finally</code> можно заменить ключевое слово <code>using</code>) и/или восстановления после исключения. Код очистки содержится в блоке <code>finally</code>. Также в блоке <code>try</code> может располагаться код, приводящий к генерации исключения. Код восстановления вставляют в один или несколько блоков <code>catch</code>. Блок <code>try</code> не может определяться сам по себе, так как это не имеет смысла, и C# запрещает такие определения.</p><p>Внутри блока <code>try</code> следует размещать ровно столько кода, сколько можно обработать одним блоком <code>catch</code>. Если же в <code>try</code> генерируется одно и то же исключение для разных строчек, но обрабатывать их необходимо по-разному, то стоит разделить данный блок на блоки поменьше.</p><h3 id="блок-catch" tabindex="-1"><a class="header-anchor" href="#блок-catch"><span>Блок catch</span></a></h3><p>В данный блок помещают код, который должен выполняться в ответ на исключение, если же исключение не возникло, то код в данном блоке не будет вызван.</p><p>Выражение в скобках после ключевого слова <code>catch</code> называется <em>типом исключения</em> (catch type). В C# эту роль играет тип <code>System.Exception</code> и его производные. Если тип исключения не указывается, то отлавливаются все типы исключений, однако информация о них не доступна.</p><p>Поиск подходящего блока <code>catch</code> в CLR осуществляется сверху вниз, поэтому наиболее конкретные обработчики должны находиться в начале списка. В противном случае компилятор сообщит об ошибке, так как менее конкретные обработчики окажутся недоступны.</p><p>Исключение, сгенерированное при выполнении блока <code>try</code>, инициирует поиск блоков <code>catch</code> соответствующего типа, а при их отсутствии - просматривается стек вызовов. Если по достижении вершины стека блок нужного типа не найден, то выбрасывается необработанное исключение.</p><p>В блоке <code>catch</code> выбирается способ восстановления после исключения из трёх вариантов:</p><ul><li>Ещё раз сгенерировать то же исключение для передачи его выше по стеку.</li><li>Сгенерировать исключение другого типа для передачи дополнительной информации выше по стеку.</li><li>Позволить программному потоку выйти из данного блока естественным образом.</li></ul><p>В первых двух случаях происходит просмотр выше по стеку в поисках блока <code>catch</code> нужного типа. В третьем случае происходит переход к блоку <code>finally</code>. Если этот блок отсутствует, то выполняется следующий после <code>catch</code> код.</p><h3 id="блок-finally" tabindex="-1"><a class="header-anchor" href="#блок-finally"><span>Блок finally</span></a></h3><p>Код блока <code>finally</code> выполняется всегда, кроме случаев, когда поток прерывается функцией <code>TerminateThread()</code> или методом <code>System.Environment.FailFast()</code>. Обычно этот блок производит очистку после выполнения блока <code>try</code>. Если же поместить очистку в код после <code>finally</code>, то она может не выполниться в случае необработанного исключения. Код блоков <code>catch</code> и <code>finally</code> должны быть максимально короткими и работающими без исключений. Если же в данных блоках возникают исключения, это может свидетельствовать о наличии серьёзных ошибок (скорее всего, о повреждении текущего состояния). Данное исключение не должно обрабатываться, так как оно уничтожает повреждённое состояние. В противном случае это может привести к непредсказуемым результатам и появлению дефектов в системе безопасности.</p><h3 id="cls-совместимые-и-cls-несовместимые-исключения" tabindex="-1"><a class="header-anchor" href="#cls-совместимые-и-cls-несовместимые-исключения"><span>CLS-совместимые и CLS-несовместимые исключения</span></a></h3><p>Все языки, ориентированные на CLR, должны поддерживать создание объектов класса <code>Exception</code>, так как этого требует CLS. Однако в CLR можно создавать исключения любых типов, хотя компилятор C# не разрешает генерировать их.</p><p>До выхода версии CLR 2.0 в блоках <code>catch</code> перехватывались только CLS-совместимые исключения. Если же метод на C# вызывал метод, написанный на другом языке, и тот генерировал CLS-несовместимое исключение, то его невозможно было отловить, что было чревато нарушением защиты.</p><p>Начиная с CLR 2.0 появился класс <code>System.Runtime.CompilerServices.RuntimeWrappedException</code>, который является производным от <code>Exception</code> и CLS-совместимым. При генерации CLS-несовместимого исключения автоматически создавался экземпляр данного класса, закрытому полю которого присваивалась ссылка на выброшенный объект. Таким образом исключение становилось CLS-совместимым. До версии 2., перехват исключений происходил примерно так:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">try</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Внутрь блока try помещают код, требующий корректного восстановления работоспособности или очистки ресурсов</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// До C# 2.0 этот блок перехватывал только CLS-совместимые исключения</span>
    <span class="token comment">// В C# 2.0 этот блок научился перехватывать также CLS-несовместимые исключения</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token comment">// Повторная генерация перехваченного исключения</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// Во всех версиях C# этот блок перехватывает и совместимые, и несовместимые с CLS исключения</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token comment">// Повторная генерация перехваченного исключения</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Если этот код перекомпилировать для CLR 2.0, последний блок <code>catch</code> никогда не будет выполняться. Для решения этой проблемы есть два способа: можно объединить последние блоки <code>catch</code> в один или можно сообщить CLR, чтобы обработка исключений работала по старым правилам (для этого сборка помечается специальным атрибутом).</p><h2 id="класс-system-exception" tabindex="-1"><a class="header-anchor" href="#класс-system-exception"><span>Класс System.Exception</span></a></h2><p>System.Exception - очень простой тип с небольшим набором свойств, которые используются при отладке. Среди них есть сообщение с текстом описания причины ошибки, имя сгенерировавшей исключение сборки, стек трейс (имена и сигнатуры методов, вызов которых стал источником исключения), имя вызвавшего исключение метода, адрес документации и исключение, в ходе обработки которого было выброшено текущее.</p><p>Информация в <code>StackTrace</code> может быть крайне полезной для поиска объекта, ставшего источником исключения, и последующего исправления кода. При обращении к этому свойству фактически происходит обращение к коду в CLR, потому что свойство не просто возвращает строку. При создании объекта типа, производного от <code>Exception</code>, данному свойству присваивается <code>null</code>. При появлении исключения CLR делает запись с указанием места его возникновения. И если в блоке <code>catch</code> обратиться к свойству <code>StackTrace</code>, то код обратится к CLR, где и будет указана строка, содержащая имена всех методов от точки, где оно было выброшено, до точки, где оно было перехвачено. При появлении исключения CLR обнуляет его начальную точку. Однако если в блоке <code>catch</code> написать <code>throw;</code> без указания исключения, то обнуление информации о стеке не производится.</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token range operator">..</span><span class="token punctuation">.</span>
    <span class="token keyword">throw</span> e<span class="token punctuation">;</span> <span class="token comment">// CLR считает, что исключение возникло тут</span>
             <span class="token comment">// FxCop сообщает об ошибке</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token range operator">..</span><span class="token punctuation">.</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span> <span class="token comment">// CLR не меняет информацию о начальной точке исключения.</span>
           <span class="token comment">// FxCop НЕ сообщает об ошибке</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>В случае возникновения необработанного исключения в систему сбора информации об ошибках уходят сведения о последнем выброшенном исключении, что может серьёзно усложнить отладку. Некоторые разработчики для обхода этого ограничения применяют некоторый костыль:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Boolean</span> trySucceeds <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token keyword">try</span>
  <span class="token punctuation">{</span>
    <span class="token range operator">..</span><span class="token punctuation">.</span>
    trySucceeds <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">finally</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>trySucceeds<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* код перехвата исключения */</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Так как <code>StackTrace</code> не включает в себя имена методов, расположенных в стеке вызова выше точки принятия исключения блоком <code>catch</code>. Для отслеживания всего стека используется тип <code>System.Diagnostics.StackTrace</code>.</p><p>Если CLR обнаруживает для сборок символические имена отладки, то стек трэйс содержит пути файлов исходного кода и номера строк. Эта информация может быть полезна для отладки.</p><h2 id="классы-исключении-определенные-в-fcl" tabindex="-1"><a class="header-anchor" href="#классы-исключении-определенные-в-fcl"><span>Классы исключений, определённые в FCL</span></a></h2><p>Описывается иерархия классов исключений. Подробнее в книге.</p><h2 id="генерирование-исключении" tabindex="-1"><a class="header-anchor" href="#генерирование-исключении"><span>Генерирование исключений</span></a></h2><p>При реализации своего метода следует генерировать исключение, если метод не в состоянии выполнить поставленную задачу. При этом необходимо учитывать два фактора:</p><ol><li>Стоит очень осмотрительно выбирать производный от <code>System.Exception</code> тип, чтобы он как можно более полно описывал возникшую проблему, и чтобы вызывающий метод мог более точно выполнить восстановительные работы. Если необходимого типа нет в FCL или дополнительных библиотеках, стоит определить новый тип. Если при написании класса исключения создаётся иерархия, то стоит подумать над тем, чтобы в ней было как можно меньше базовых классов, потому что в таком случае будет меньше возможностей указать в блоке <code>catch</code> базовый класс и описать более точное восстановительное поведение.</li><li>Следует максимально полно описывать причину ошибки в тексте сообщения об ошибке исключения. Эту информацию можно свободно писать в логи, так как у пользователей нет доступа к этим данных, а разработчикам будет проще исправлять ошибки, возникшие во время выполнения, а не отладки</li></ol><h2 id="создание-классов-исключении" tabindex="-1"><a class="header-anchor" href="#создание-классов-исключении"><span>Создание классов исключений</span></a></h2><p>Описывается создание классов исключений. Подробнее в книге.</p><h2 id="продуктивность-вместо-надежности" tabindex="-1"><a class="header-anchor" href="#продуктивность-вместо-надежности"><span>Продуктивность вместо надёжности</span></a></h2><p>ООП позволяет добиться высокой продуктивности за счёт композиционных удобств, которые облегчают, чтение, написание и поддержку кода.</p><p>Продуктивность разработки достигается не только за счёт композиционности кода, но и благодаря некоторым возможностям компиляторов, среди которых неявные:</p><ul><li>Вставка в вызываемый метод необязательных параметров.</li><li>Упаковка экземпляров значимого типа.</li><li>Создание и инициализация массивов параметров.</li><li>Связывание с членами динамических и переменных выражений.</li><li>Связывание с методами расширения.</li><li>Связывание с перегруженными операторами и их вызов.</li><li>Создание делегатов.</li><li>Автоматическое определение типа при вызове обобщённых методов, объявлении локальных переменных и использовании лямбда выражений.</li><li>Определение и создание классов замыканий (closure) для лямбда-выражений и итераторов.</li><li>Определение, создание и инициализация анонимных типов и их экземпляров.</li><li>Написание кода поддержки LINQ.</li></ul><p>Кроме этого, CLR умеет неявно:</p><ul><li>Вызывать виртуальные и интерфейсные методы.</li><li>Загружать сборки и JIT-компилируемые методы, которые могут стать причиной некоторых исключений.</li><li>Пересекать границы домена приложения для доступа к объектам, которые могут стать источником исключений.</li><li>Сериализовывать и десериализовывать объекты при пересечении границы домена.</li><li>Заставлять потоки генерировать исключения.</li><li>Вызывать методы, выполняющие завершающие операции до освобождения памяти сборщиком мусора.</li><li>Создавать типы в куче загрузчика при работе с обобщёнными типами.</li><li>Вызывать статический конструктор типа, который может стать источником исключения.</li><li>Генерировать прочие исключения.</li></ul><p>И, разумеется, .NET Framework поставляется с обширной библиотекой классов, любая часть из которых может стать источником ошибки.</p><p>Всё это вместе: ООП, компилятор, CLR и библиотеки классов являются не только удобной платформой для разработки ПО, но также и потенциальным источником ошибок.</p><p>Написание неустойчивого и ненадёжного считается допустимым именно из-за всего вышеописанного разнообразия - учитывать все возможные ошибки не практично. Более того, порой это вообще невозможно. Следует учитывать и то, что ошибки возникают достаточно редко, так что было решено пожертвовать надёжностью кода в угоду продуктивности разработчиков.</p><p>Исключения хороши ещё и тем, что необработанные исключения приводят к аварийному завершению. Такое поведение проще отследить и исправить на этапе тестирования. Некоторые компании против такого подхода, поэтому перехватывают всё. Хотя это может привести к дальнейшей работе приложения с испорченным состоянием.</p><p>Есть несколько подходов, способных сгладить проблему испорченного состояния:</p><ul><li>CLR запрещает аварийно завершать потоки во время выполнения кода в блоках <code>catch</code> и <code>finally</code>. Тем не менее не стоит помещать весь код внутрь этих блоков. Этот приём можно использовать только для изменения самых чувствительных состояний.</li><li>Класс <code>System.Diagnostics.Contracts.Contract</code> позволяет применять к методам контракты кода. Они позволяют проверять аргументы и другие переменные перед модификацией состояния. В случае соответствия контракте вероятность повреждения состояния минимальна. Если проверка не проходит, генерируется исключение.</li><li>Области ограниченного исполнения (CER) позволяют избежать имеющихся в CLR неоднозначностей. Перед входом в блок <code>try</code> можно загрузить все требуемые сборки и скомпилировать код внутри <code>catch</code> и <code>finally</code>. Это позволит избежать часть исключений, связанных с CLR.</li><li>В зависимости от местоположения состояния можно использовать транзакции.</li><li>Можно сделать методы более явными.</li></ul><p>Если же состояние испорчено настолько, что не подлежит восстановлению, его надлежит удалить, а затем перезапустить приложение, чтобы инициализировать состояние нормально. Так как управляемое состояние не выходит за границы домена, то для устранения достаточно выгрузить домен приложения.</p><h2 id="приемы-работы-с-исключениями" tabindex="-1"><a class="header-anchor" href="#приемы-работы-с-исключениями"><span>Приёмы работы с исключениями</span></a></h2><p>При разработке общедоступных библиотек классов стоит учесть, что код не должен решать, что есть ошибка, а что нет — это должно остаться на стороне вызывающего кода и на совести разработчиков приложений.</p><h3 id="активно-используите-блоки-finally" tabindex="-1"><a class="header-anchor" href="#активно-используите-блоки-finally"><span>Активно используйте блоки finally</span></a></h3><p>В C# при использовании конструкций <code>lock</code>, <code>using</code> и <code>foreach</code>, а также при переопределении деструктора класса (метод <code>Finalize()</code>) блоки <code>try</code>/<code>finally</code> создаются автоматически. Написанный разработчиком код помещается в метод <code>try</code>, а в блок <code>finally</code> помещаются соответственно:</p><ul><li>Снятие блокировки.</li><li>Вызов метода <code>Dispose()</code> для объекта.</li><li>Вызов метода <code>Dispose()</code> для объекта IEnumerator.</li><li>Вызов метода <code>Finalize()</code> базового класса.</li></ul><h3 id="не-надо-перехватывать-все-исключения" tabindex="-1"><a class="header-anchor" href="#не-надо-перехватывать-все-исключения"><span>Не надо перехватывать все исключения</span></a></h3><p>Не стоит перехватывать абсолютно все исключения, потому что перехват — это заявление, что исключение ожидалось, а причины и способы обработки известны. Другими словами, через исключения определяется политика приложения.</p><p>Если исключение осталось необработанным, CLR завершает процесс. Большинство таких исключений отлавливаются на этапе тестирования. Для борьбы с ними стоит либо заставить код реагировать на <em>определённое</em> исключение, либо переписать код, устранив причины возникновения данного исключения.</p><p>Вполне допустимо перехватывать <code>System.Exception</code> с целью обработки и передачи его дальше по стеку. перехват и поглощение (без повторного генерирования) недопустимо, так как оно приводит к сокрытию факта сбоя.</p><p>Наконец, допускается перехватить исключение в одном потоке и повторного сгенерировать его в другом, чтобы ошибка не была скрыта от приложения.</p><h3 id="корректное-восстановление-после-исключения" tabindex="-1"><a class="header-anchor" href="#корректное-восстановление-после-исключения"><span>Корректное восстановление после исключения</span></a></h3><p>Перехватывая конкретные исключения, необходимо полностью осознавать вызывающие их обстоятельства и знать типы исключений, производные от перехваченного.</p><h3 id="отмена-незавершенных-операции-при-невосстановимых-исключениях" tabindex="-1"><a class="header-anchor" href="#отмена-незавершенных-операции-при-невосстановимых-исключениях"><span>Отмена незавершённых операций при невосстановимых исключениях</span></a></h3><p>Для корректной отмены незавершённых операций код должен перехватывать все исключения, так как важен не тип ошибки, а возвращение структур данных в согласованное состояние. После этого необходимо сообщить вызывающему коду об исключении, прокинув его вверх по стеку.</p><h3 id="сокрытие-деталеи-реализации-для-сохранения-контракта" tabindex="-1"><a class="header-anchor" href="#сокрытие-деталеи-реализации-для-сохранения-контракта"><span>Сокрытие деталей реализации для сохранения контракта</span></a></h3><p>Иногда бывает полезно после перехвата одного типа исключения сгенерировать исключение другого типа. Это может быть необходимо для сохранения смысла контракта метода.</p><p>Повторное генерирование исключения сообщает вызывающему коду о том, что метод не в состоянии решить свою задачу. Новое исключение даёт ему абстрактное представление о причине сбоя, а внутреннее исключение - реальную причину, знание которой может быть полезно разработчику.</p><p>Следует с осторожностью использовать данный приём, так как, во-первых, скрывается реальная причина, а во-вторых, перетирается <code>StackTrace</code>, что также сообщает ложные сведения о месте возникновения неисправности.</p><p>Иногда генерация нового исключения после перехвата уже имеющегося преследует целью добавление к исключению новых данных или контекста. Однако этого можно достичь гораздо проще: достаточно перехватить исключение нужного типа, добавить в коллекцию его свойства <code>Data</code> требуемую информацию и сгенерировать его заново.</p><p>При вызове метода через рефлексию CLR автоматически перехватывает все генерируемые этим методом исключения и преобразует их в тип <code>TargetInvocationException</code>. В результате для поиска сведений приходится идти в отладчик и смотреть свойство <code>InnerException</code>. Именно поэтому многие разработчики предпочитают использовать тип <code>dynamic</code>, так как он не перехватывает исключения и не генерирует <code>TargetInvocationException</code>, а перемещает исходное исключение вверх по стеку.</p><h2 id="необработанные-исключения" tabindex="-1"><a class="header-anchor" href="#необработанные-исключения"><span>Необработанные исключения</span></a></h2><p>При появлении исключения CLR начинает в стеке вызовов поиск блока <code>catch</code> с соответствующим типом исключения. Если не найден ни один такой блок, возникает <em>необработанное исключение</em> (unhandled exception). Обнаружив в процессе поток в необработанным исключением, CLR его уничтожает. Необработанное исключение указывает на непредусмотренную программистом ситуацию и должно считаться признаком ошибки в приложении.</p><p>Разработчики вправе разработать свою собственную систему получения информации о необработанных исключениях, необходимую для устранения недостатков программы. При инициализации приложения можно проинформировать CLR о том, что существует метод, который нужно вызывать каждый раз, когда в каком-либо потоке возникает необработанное исключение.</p><p>В идеальном мире серверное приложение, в котором случилось необработанное исключение, зарегистрирует сведения об исключении в журнале, уведомит клиента о невозможности выполнения запрошенной операции и завершит свою работу. Однако в реальном мире так делать очень непрактично.</p><p>В серверном приложении информацию о необработанном исключении нельзя возвращать клиенту, так как ему от этих сведений мало пользы. Более того, сервер должен сообщать клиентам как можно меньше информации о себе, так как это снижает вероятность хакерской атаки.</p><h2 id="отладка-исключении" tabindex="-1"><a class="header-anchor" href="#отладка-исключении"><span>Отладка исключений</span></a></h2><p>В отладчике Microsoft Visual Studio есть возможность отметить, на выкидывании каких исключений стоит останавливаться, чтобы отловить ошибку на месте. По умолчанию выставлено только необработанное исключение, так как предполагается, что, если исключение обработано, значит, программа работает так, как и задумано. Кроме того, в отладчике доступна возможность добавления своих собственных типов исключений (не только унаследованных от <code>System.Exception</code>).</p><h2 id="скорость-обработки-исключении" tabindex="-1"><a class="header-anchor" href="#скорость-обработки-исключении"><span>Скорость обработки исключений</span></a></h2><p>Некоторые программисты считают, что обработка исключений слишком медленна, поэтому отказываются к ней прибегать. Однако альтернативные варианты (возвращение булева значения из метода, свидетельствующего об успехе, или кода ошибки, закодированного некоторым перечислимым типом) лишь приводят к столкновению с худшими сторонами обоих решений. CLR и код библиотек всё равно будут генерировать исключения, а код разработчиков будет генерировать ещё и код ошибок. Получается двойная работа, которая не происходит быстрее, чем классическая обработка ошибок. Дополнительно к этому разрастается кодовая база, что также не лучшим образом сказывается на продуктивности разработчиков и быстродействии.</p><p>Неуправляемые компиляторы C++ генерируют код, отслеживающий успешное создание объектов, а также код, который при перехвате исключений будет вызывать для этих объектов деструкторы. При этом значительно увеличивается как объём кода, так и время выполнения.</p><p>Управляемым компиляторам вести учёт объектов намного легче, потому что память для них выделяется из управляемой кучи, за которой следит сборщик мусора. Если объект был успешно создан, а затем возникло исключение, то сборщик мусора, в конечном счёте, освободит занятую этим объектом память. Это значит, что в сравнении с неуправляемым компилятором генерируется меньше кода, меньше кода обрабатывается, а результате чего растёт быстродействие.</p><p>ООП повышает производительность труда программистов за счёт того, что конструкторы, методы и свойства создаются с расчётом на отсутствие сбоев. Однако если позже выяснится, что какой-либо метод генерирует слишком много исключений, стоит подумать над тем, чтобы добавить методы, которые возвращают в качестве результата булево значение об успешности операции (например, метод <code>TryParse()</code>).</p><h2 id="области-ограниченного-выполнения" tabindex="-1"><a class="header-anchor" href="#области-ограниченного-выполнения"><span>Области ограниченного выполнения</span></a></h2><p>Во многих приложениях не нужна высокая надёжность и способность к восстановлению, так что они могут просто завершить свою работу из-за необработанных исключений. Многие серверные приложения (например, веб-серверы) не имеют долгосрочного состояния и в случае необработанных исключений автоматически перезагружаются. Но для некоторых серверов (например SQL-сервер) потеря данных будет более критичной.</p><p>В CLR информация о состоянии хранится в домене, а его выгрузка сопровождается выгрузкой всего состояния, соответственно, если поток в домене приложений сталкивается с необработанным исключением, он может выгрузить домен (удалить все состояния), не завершая всего процесса.</p><p><em>Областью ограниченного выполнения</em> (Constrained Execution Region, CER) называется фрагмент кода, который должен быть устойчивым к сбоям. Так как домены допускают выгрузку всего состояния, CER обычно служат для управления распределённым между доменами или процессами состоянием. Особенно они полезны при работе с состоянием, для которого возможно неожиданные исключения, которые ещё называют <em>асинхронными</em> (asynchronous exceptions).</p><p>При создании области ограниченного выполнения до блока <code>try</code>, JIT-компилятор немедленно начинает компилировать соответствующие блоки <code>catch</code> и <code>finally</code> (загружать сборки, создавать типы, вызывать статические конструкторы и компилировать методы). Если хотя бы одна из операций даст сбой, то блок <code>try</code> не будет выполняться. Для этого надо пометить методы соответствующими атрибутами, которые сообщат компилятору, что данные элементы не повредят домен приложения или состояние процесса.</p><p>Чтобы написать надёжный метод, стоит делать его как можно меньше и ограничивать его сферу действия. Стоит также убедиться, что не выделяется память под объекты, внутри не вызываются виртуальные или интерфейсные методы, не использованы делегаты или отражения, так как в данном случае JIT-компилятор не сможет определить, какой именно метод вызывается на самом деле.</p><h2 id="контракты-кода" tabindex="-1"><a class="header-anchor" href="#контракты-кода"><span>Контракты кода</span></a></h2><p><em>Контракты кода</em> (code contracts) — это механизм декларативного документирования решений, принятых в ходе проектирования кода, внутри самого кода. Контракты бывают трёх видов:</p><ul><li><em>Предусловия</em> (preconditions) - используются для проверки аргументов.</li><li><em>Постусловия</em> (postconditions) - используются для проверки состояния завершения метода вне зависимости от наличия или отсутствия исключения.</li><li><em>Инварианты</em> (object invariants) - позволяют удостовериться, что данные объекта находятся в хорошем состоянии на протяжении всего объекта.</li></ul><p>Контракты облегчают использование кода, его понимание, разработку и тестирование, документирование и распознавание ошибок на ранних стадиях. Контракты можно представить в виде части сигнатуры методов. При этом можно ослабить контракт в новых версиях, но обратного сделать нельзя, так как это скажется на совместимости.</p><p>Подробнее о том, как определяются контракты, можно прочитать в главе.</p><p>Объявлять предусловия и постусловия стоит в верхней части методов, чтобы их было легко найти. Предусловия проверяются при вызове метода. Постусловия проверяются перед завершением метода. Инварианты проверяют состояние объекта после возвращения значения каждым из методов.</p>`,99),i=[l];function t(p,o){return a(),s("div",null,i)}const r=n(c,[["render",t],["__file","ch20_ExceptionsAndStateManae.html.vue"]]),u=JSON.parse('{"path":"/ru/chapters/ch20_ExceptionsAndStateManae.html","title":"Исключения и управление состоянием","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Определение \\"исключения\\"","slug":"определение-исключения","link":"#определение-исключения","children":[]},{"level":2,"title":"Механика обработки исключений","slug":"механика-обработки-исключении","link":"#механика-обработки-исключении","children":[{"level":3,"title":"Блок try","slug":"блок-try","link":"#блок-try","children":[]},{"level":3,"title":"Блок catch","slug":"блок-catch","link":"#блок-catch","children":[]},{"level":3,"title":"Блок finally","slug":"блок-finally","link":"#блок-finally","children":[]},{"level":3,"title":"CLS-совместимые и CLS-несовместимые исключения","slug":"cls-совместимые-и-cls-несовместимые-исключения","link":"#cls-совместимые-и-cls-несовместимые-исключения","children":[]}]},{"level":2,"title":"Класс System.Exception","slug":"класс-system-exception","link":"#класс-system-exception","children":[]},{"level":2,"title":"Классы исключений, определённые в FCL","slug":"классы-исключении-определенные-в-fcl","link":"#классы-исключении-определенные-в-fcl","children":[]},{"level":2,"title":"Генерирование исключений","slug":"генерирование-исключении","link":"#генерирование-исключении","children":[]},{"level":2,"title":"Создание классов исключений","slug":"создание-классов-исключении","link":"#создание-классов-исключении","children":[]},{"level":2,"title":"Продуктивность вместо надёжности","slug":"продуктивность-вместо-надежности","link":"#продуктивность-вместо-надежности","children":[]},{"level":2,"title":"Приёмы работы с исключениями","slug":"приемы-работы-с-исключениями","link":"#приемы-работы-с-исключениями","children":[{"level":3,"title":"Активно используйте блоки finally","slug":"активно-используите-блоки-finally","link":"#активно-используите-блоки-finally","children":[]},{"level":3,"title":"Не надо перехватывать все исключения","slug":"не-надо-перехватывать-все-исключения","link":"#не-надо-перехватывать-все-исключения","children":[]},{"level":3,"title":"Корректное восстановление после исключения","slug":"корректное-восстановление-после-исключения","link":"#корректное-восстановление-после-исключения","children":[]},{"level":3,"title":"Отмена незавершённых операций при невосстановимых исключениях","slug":"отмена-незавершенных-операции-при-невосстановимых-исключениях","link":"#отмена-незавершенных-операции-при-невосстановимых-исключениях","children":[]},{"level":3,"title":"Сокрытие деталей реализации для сохранения контракта","slug":"сокрытие-деталеи-реализации-для-сохранения-контракта","link":"#сокрытие-деталеи-реализации-для-сохранения-контракта","children":[]}]},{"level":2,"title":"Необработанные исключения","slug":"необработанные-исключения","link":"#необработанные-исключения","children":[]},{"level":2,"title":"Отладка исключений","slug":"отладка-исключении","link":"#отладка-исключении","children":[]},{"level":2,"title":"Скорость обработки исключений","slug":"скорость-обработки-исключении","link":"#скорость-обработки-исключении","children":[]},{"level":2,"title":"Области ограниченного выполнения","slug":"области-ограниченного-выполнения","link":"#области-ограниченного-выполнения","children":[]},{"level":2,"title":"Контракты кода","slug":"контракты-кода","link":"#контракты-кода","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch20_ExceptionsAndStateManae.md"}');export{r as comp,u as data};
