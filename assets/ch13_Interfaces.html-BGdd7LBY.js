import{_ as n,o as s,c as a,e}from"./app-IxoMmWNN.js";const p={},t=e(`<h1 id="интерфеисы" tabindex="-1"><a class="header-anchor" href="#интерфеисы"><span>Интерфейсы</span></a></h1><p>Некоторые языки поддерживают концепцию <em>множественного наследования</em> (multiple inheritance), но ни CLR, а следовательно и не C#. Но CLR позволяет реализовать ограниченное множественное наследование через интерфейсы.</p><h2 id="наследование-в-классах-и-интерфеисах" tabindex="-1"><a class="header-anchor" href="#наследование-в-классах-и-интерфеисах"><span>Наследование в классах и интерфейсах</span></a></h2><p>В .NET все классы наследуются от <code>object</code>, а это значит, что код, оперирующий данным классом, может выполнять операции с экземпляром любого класса.</p><p>Любой производный от <code>object</code> класс наследует:</p><ul><li><strong>Сигнатуры методов.</strong> Это позволяет считать, что код оперирует элементом типа <code>object</code>, когда на самом деле работает с экземпляром другого класса.</li><li><strong>Реализацию этих методов.</strong> Наследуемые методы можно не реализовывать вручную.</li></ul><p>В CLR у класса может быть только один базовый класс (который прямо или опосредованно наследуется от <code>object</code>). Базовый класс предоставляет сигнатуры и реализации методов. При этом новый класс может стать базовым для ещё одного, и тот также унаследует все сигнатуры и реализации.</p><p>CLR также позволяет определить <em>интерфейс</em>, который, в сущности, представляет собой средство назначения имени набору сигнатур методов. Интерфейс не содержит реализаций. Класс наследует интерфейс через указание имени, причём класс должен явно содержать реализации методов.</p><p>Аналогично подстановке экземпляров производного типа в контекст, где требуется базовый тип, можно выполнять подстановку классу в контекст, где вызывается реализуемый классом интерфейс.</p><h2 id="определение-интерфеисов" tabindex="-1"><a class="header-anchor" href="#определение-интерфеисов"><span>Определение интерфейсов</span></a></h2><p>Интерфейс представляет собой именованный набор сигнатур методов. При этом в интерфейсах можно так же объявлять события и свойства (которые и так соответствуют методам).</p><p>CLR допускает наличие в интерфейсах статических полей, но они не входят в CLS. В C# это можно делать, начиная с 11 версии языка.</p><p>В C# интерфейс определяется с помощью ключевого слова <code>interface</code>.</p><p>С точки зрения CLR, определение интерфейса - почти то же, что и определение типа. То есть CLR определяет внутреннюю структуру данных для объекта интерфейсного типа, а для обращения к членам интерфейса можно использовать рефлексию. Интерфейсы могут определяться на уровне файла или быть вложенными в другие типы. Кроме этого, при определении интерфейсов можно указать область видимости и доступа.</p><p>Имена интерфейсов начинаются с буквы <code>I</code>, что облегчает их поиск. Интерфейсы могут быть обобщёнными.</p><p>Определении интерфейса может наследовать другие интерфейсы, однако наследование здесь работает иначе, чем в классах. Это можно рассматривать как включение в интерфейс контрактов других интерфейсов, то есть:</p><ul><li>Класс, реализующий интерфейс, должен реализовать и методы из интерфейсов, которые наследует интерфейс класса.</li><li>Любой код, ожидающий реализацию интерфейса, может быть уверен, что тип объекта реализует и методы наследуемых интерфейсов.</li></ul><h2 id="наследование-интерфеисов" tabindex="-1"><a class="header-anchor" href="#наследование-интерфеисов"><span>Наследование интерфейсов</span></a></h2><p>Компилятор C# требует, чтобы метод, реализующий интерфейс, был открытым. CLR требует, чтобы интерфейсные методы были виртуальными. Если метод явно не определён в коде как виртуальный, компилятор сделает его таковым и, вдобавок, запечатанным. Это не позволяет производному классу переопределять интерфейсные методы. Если же явно пометить метод как виртуальный, его можно будет переопределить в наследниках.</p><p>Производный класс не в состоянии переопределять интерфейсные методы, объявленные запечатанными, но может повторно унаследовать интерфейс и предоставить собственную реализацию методов. При вызове интерфейсного метода вызывается реализация, связанная с типом самого объекта.</p><h2 id="подробнее-о-вызовах-интерфеисных-методов" tabindex="-1"><a class="header-anchor" href="#подробнее-о-вызовах-интерфеисных-методов"><span>Подробнее о вызовах интерфейсных методов</span></a></h2><p>Тип <code>string</code> наследуется от <code>object</code> и реализует несколько интерфейсов. Это значит, что ему не надо переопределять методы <code>object</code>, но надо определить методы интерфейсов.</p><p>CLR допускает определение полей, параметров или локальных переменных интерфейсного типа. Используя такую переменную, можно вызывать методы, определённые интерфейсом. А также можно вызывать методы <code>object</code>, поскольку все классы наследуют его методы.</p><p>В коде можно объявить переменную типа <code>string</code> и присвоить её переменной тип одного из реализуемых типом <code>string</code> интерфейса. Тогда все переменные будут ссылаться на один объект в управляемой куче. Но тип переменной определяет действие, которое можно выполнить с объектом.</p><p>Как и ссылочный тип, значимый тип может реализовывать несколько интерфейсов. Но при приведении экземпляра значимого типа к интерфейсному происходит упаковка, потому что переменная интерфейсного типа является ссылкой на объект в куче, чтобы CLR могла проверить указатель и точно выяснить тип объекта. Затем при вызове метода интерфейса у упакованного объекта CLR использует указатель, чтобы найти таблицу методов объекта-типа и вызвать нужный метод.</p><h2 id="явные-и-неявные-реализации-интерфеисных-методов-что-происходит-за-кулисами" tabindex="-1"><a class="header-anchor" href="#явные-и-неявные-реализации-интерфеисных-методов-что-происходит-за-кулисами"><span>Явные и неявные реализации интерфейсных методов (что происходит за кулисами)</span></a></h2><p>Когда тип загружается в CLR, для него создаётся и инициализируется таблица методов. Она содержит по одной записи для каждого нового, представленного только этим типом метода, а также записи для всех виртуальных методов, унаследованных типом. Унаследованные методы включают методы, определённые в базовых типах иерархии, а также все методы, определённые интерфейсными типами.</p><p>Пусть имеется простое определение типа:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Dispose&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Таблица методов типа содержит следующие записи:</p><ul><li>Все экземплярные методы, определённые в object и неявно унаследованные от него.</li><li>Все интерфейсные методы, определённые в явно унаследованным интерфейсе.</li><li>Новый метод, появившийся в типе.</li></ul><p>компилятор C# считает, что новый метод является реализацией метода интерфейса. Компилятор вправе сделать такое предположение, потому что метод открытый, а сигнатуры методов совпадают. Однако, если бы новый метод был помечен как виртуальный, компилятор бы всё равно сопоставил их. Сопоставляя методы, компилятор генерирует метаданные, указывающие на то, что обе записи в таблице методов должны ссылаться на одну реализацию. То есть вне зависимости от того, вызываем мы метод типа или интерфейсный, мы получим одну и ту же реализацию. Если же переписать тип:</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleType</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IDisposable</span></span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;public Dispose&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token return-type class-name"><span class="token keyword">void</span></span> IDisposable<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;IDisposable Dispose&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Если перед именем метода указано имя интерфейса, то создаётся <em>явная реализация интерфейсного метода</em> (Explicit Interface Method Implementation, EIMI). При явной реализации интерфейсного метода в C# нельзя указывать уровень доступа. Однако компилятор назначает для этого метода закрытый уровень доступа, что запрещает любому кода использовать экземпляр класса простым вызовом интерфейсного метода. Единственный способ вызвать интерфейсный метод - обратиться через переменную интерфейсного типа.</p><p>Стоит заметить, что явно реализованный метод не может быть виртуальным, его нельзя переопределить. Происходит это потому, что данный метод в действительности не является частью объектной модели типа, это всего лишь средство связывания интерфейса с типом.</p><h2 id="обобщенные-интерфеисы" tabindex="-1"><a class="header-anchor" href="#обобщенные-интерфеисы"><span>Обобщённые интерфейсы</span></a></h2><p>Обобщённые интерфейсы обеспечивают безопасность типов на стадии компиляции, так как в необобщённых интерфейсах определены методы, принимающие в качестве параметра <code>object</code>, что может привести к ошибке во время выполнения, например, в попытках сравнить значения разных типов.</p><p>Второе преимущество обобщённых интерфейсов состоит в том, что при работе со значимыми типами требуется меньше операций упаковки.</p><p>В FCL реализованы обобщ1нные и необобщённые версии интерфейсов. Необобщённые версии оставлены для обратной совместимости, поэтому лучше использовать именно обобщённые версии.</p><p>Третье преимущество обобщённых интерфейсов состоит в том, что класс может реализовывать один интерфейс многократно, просто используя параметры различного типа. Параметры обобщённого типа могут быть помечены как контравариантные и ковариантные.</p><h2 id="обобщения-и-ограничения-интерфеиса" tabindex="-1"><a class="header-anchor" href="#обобщения-и-ограничения-интерфеиса"><span>Обобщения и ограничения интерфейса</span></a></h2><p>Первое преимущество ограничениях параметров-типов интерфейсами состоит в том, что параметр-тип можно ограничивать несколькими интерфейсами, и тогда тип должен реализовывать все ограничения. Такое поведение позволяет отсечь множество ошибок ещё на этапе компиляции.</p><p>Второе преимущество - избавление от упаковки при передаче экземпляров значимого типа. Если же объявить интерфейс не ограничением обобщённого метода, а параметром метода, то будет происходить упаковка.</p><p>Для ограничений интерфейсов компилятор генерирует определённые IL-инструкции, которые вызывают интерфейсные методы для значимого типа напрямую. В иных случаях всегда будет происходить упаковка.</p><h2 id="реализация-нескольких-интерфеисов-с-одинаковыми-сигнатурами-и-именами-методов" tabindex="-1"><a class="header-anchor" href="#реализация-нескольких-интерфеисов-с-одинаковыми-сигнатурами-и-именами-методов"><span>Реализация нескольких интерфейсов с одинаковыми сигнатурами и именами методов</span></a></h2><p>При реализации нескольких интерфейсов с одинаковыми сигнатурами и именами методов необходимо явно указать имя метода. Тогда для типа будет вызываться метод, определённый в нём, а при приведении к типу интерфейса - метод этого интерфейса.</p><h2 id="совершенствование-безопасности-типов-за-счет-явнои-реализации-интерфеисных-методов" tabindex="-1"><a class="header-anchor" href="#совершенствование-безопасности-типов-за-счет-явнои-реализации-интерфеисных-методов"><span>Совершенствование безопасности типов за счёт явной реализации интерфейсных методов</span></a></h2><p>Интерфейсы удобны тем, что они предоставляют стандартный механизм взаимодействия между типами. Обобщённые типы хорошо повышают безопасность типов при компиляции и позволяют избавиться от упаковки. Однако иногда приходится реализовывать необобщённые интерфейсы, так как обобщённой версии попросту нет. Такие типы очень часто оперируют типом <code>object</code>, что нарушает безопасность и приводит к упаковке.</p><p>Используя явную реализацию интерфейсного метода, мы объявляем в типе похожий метод, который, однако, оперирует не <code>object</code>, а самим типом. В реализации интерфейсного метода мы приводим объект к нашему типу и вызываем экземплярный метод. Тогда для вызова метода нашего типа не нарушается безопасность и не происходит упаковки. Однако при приведении нашего типа к интерфейсу, все преимущества теряются.</p><p>К явной реализации интерфейсных методов часто прибегают, если необходимо реализовать именно необобщённый интерфейс.</p><h2 id="опасности-явнои-реализации-интерфеисных-методов" tabindex="-1"><a class="header-anchor" href="#опасности-явнои-реализации-интерфеисных-методов"><span>Опасности явной реализации интерфейсных методов</span></a></h2><p>С явной реализацией интерфейсных методов связаны некоторые проблемы:</p><ul><li><strong>Отсутствие документации, объясняющей, как именно тип реализует явный метод, а также отсутствие поддержки в IDE.</strong> В описаниях методов типа в документации можно найти сведения о явной реализации, однако вызвать эти методы нельзя, что только вводит разработчика в замешательство.</li><li><strong>При приведении к интерфейсному типу экземпляры значимого типа упаковываются.</strong></li><li><strong>Явную реализацию интерфейсных методов нельзя вызвать из производного типа.</strong> Лучший способ исправить это - в дополнение к явно реализованному методу создать в базовом классе виртуальный метод, который можно будет переопределить в наследниках.</li></ul><p>Явная реализация методов полезна лишь в некоторых случаях, но её стоит избегать везде, где это возможно.</p><h2 id="дилемма-разработчика-базовыи-класс-или-интерфеис" tabindex="-1"><a class="header-anchor" href="#дилемма-разработчика-базовыи-класс-или-интерфеис"><span>Дилемма разработчика: базовый класс или интерфейс?</span></a></h2><p>Несколько правил для правильного выбора:</p><ul><li><strong>Связь потомка с предком.</strong> Если производный тип не может ограничиваться отношением &quot;является частным случаем&quot;, то стоит использовать интерфейс. Интерфейс подразумевает отношение типа &quot;поддерживает функциональность&quot;. Значимые типы не могут наследоваться, поэтому здесь можно использовать только интерфейсы.</li><li><strong>Простота использования.</strong> При наследовании от базового типа вносятся лишь незначительные изменения, при реализации интерфейса реализуется всё.</li><li><strong>Чёткая реализация.</strong> Базовый тип с хорошей реализацией основных функций - хорошая отправная точка.</li><li><strong>Управление версиями.</strong> При добавлении нового члена в базовый тип, ничего не нужно менять и даже перекомпилировать. Внесение изменений в интерфейс требует усилий по доработке.</li></ul>`,57),l=[t];function c(o,i){return s(),a("div",null,l)}const d=n(p,[["render",c],["__file","ch13_Interfaces.html.vue"]]),u=JSON.parse('{"path":"/ru/chapters/ch13_Interfaces.html","title":"Интерфейсы","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Наследование в классах и интерфейсах","slug":"наследование-в-классах-и-интерфеисах","link":"#наследование-в-классах-и-интерфеисах","children":[]},{"level":2,"title":"Определение интерфейсов","slug":"определение-интерфеисов","link":"#определение-интерфеисов","children":[]},{"level":2,"title":"Наследование интерфейсов","slug":"наследование-интерфеисов","link":"#наследование-интерфеисов","children":[]},{"level":2,"title":"Подробнее о вызовах интерфейсных методов","slug":"подробнее-о-вызовах-интерфеисных-методов","link":"#подробнее-о-вызовах-интерфеисных-методов","children":[]},{"level":2,"title":"Явные и неявные реализации интерфейсных методов (что происходит за кулисами)","slug":"явные-и-неявные-реализации-интерфеисных-методов-что-происходит-за-кулисами","link":"#явные-и-неявные-реализации-интерфеисных-методов-что-происходит-за-кулисами","children":[]},{"level":2,"title":"Обобщённые интерфейсы","slug":"обобщенные-интерфеисы","link":"#обобщенные-интерфеисы","children":[]},{"level":2,"title":"Обобщения и ограничения интерфейса","slug":"обобщения-и-ограничения-интерфеиса","link":"#обобщения-и-ограничения-интерфеиса","children":[]},{"level":2,"title":"Реализация нескольких интерфейсов с одинаковыми сигнатурами и именами методов","slug":"реализация-нескольких-интерфеисов-с-одинаковыми-сигнатурами-и-именами-методов","link":"#реализация-нескольких-интерфеисов-с-одинаковыми-сигнатурами-и-именами-методов","children":[]},{"level":2,"title":"Совершенствование безопасности типов за счёт явной реализации интерфейсных методов","slug":"совершенствование-безопасности-типов-за-счет-явнои-реализации-интерфеисных-методов","link":"#совершенствование-безопасности-типов-за-счет-явнои-реализации-интерфеисных-методов","children":[]},{"level":2,"title":"Опасности явной реализации интерфейсных методов","slug":"опасности-явнои-реализации-интерфеисных-методов","link":"#опасности-явнои-реализации-интерфеисных-методов","children":[]},{"level":2,"title":"Дилемма разработчика: базовый класс или интерфейс?","slug":"дилемма-разработчика-базовыи-класс-или-интерфеис","link":"#дилемма-разработчика-базовыи-класс-или-интерфеис","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch13_Interfaces.md"}');export{d as comp,u as data};
