import{_ as e,o as a,c as l,e as c}from"./app-IxoMmWNN.js";const d={},r=c('<h1 id="параметры" tabindex="-1"><a class="header-anchor" href="#параметры"><span>Параметры</span></a></h1><h2 id="необязательные-и-именованные-параметры" tabindex="-1"><a class="header-anchor" href="#необязательные-и-именованные-параметры"><span>Необязательные и именованные параметры</span></a></h2><h4 id="прим-тот-же-мартин-утверждает-что-использование-необязательных-параметров-является-антипаттерном-так-как-ухудшает-читаемость-кода-я-в-этом-с-ним-согласен-однако-для-общего-образования-стоит-знать-как-необязательные-параметры-реализуются" tabindex="-1"><a class="header-anchor" href="#прим-тот-же-мартин-утверждает-что-использование-необязательных-параметров-является-антипаттерном-так-как-ухудшает-читаемость-кода-я-в-этом-с-ним-согласен-однако-для-общего-образования-стоит-знать-как-необязательные-параметры-реализуются"><span>Прим. <em>Тот же Мартин утверждает, что использование необязательных параметров является антипаттерном, так как ухудшает читаемость кода. Я в этом с ним согласен, однако для общего образования стоит знать, как необязательные параметры реализуются.</em></span></a></h4><p>Некоторым (или даже всем) параметрам метода можно присваивать значения по умолчанию, в результате чего их можно не передавать при вызове. Кроме того, при вызове метода существует возможность указать аргументы явно, воспользовавшись именами параметров.</p><h3 id="правила-использования-параметров" tabindex="-1"><a class="header-anchor" href="#правила-использования-параметров"><span>Правила использования параметров</span></a></h3><p>Определяя параметры по умолчанию, стоит руководствоваться следующими правилами:</p><ul><li>Значения по умолчанию можно указывать для методов, конструкторов и параметрических свойств. Также можно указать для параметров, являющихся частью делегатов.</li><li>Параметры по умолчанию должны следовать за всеми остальными.</li><li>Во время компиляции параметры по умолчанию должны оставаться неизменными, то есть они должны быть примитивных типов. Также ими могут быть перечисления и ссылочные типы, допускающие <code>null</code>. Для значимого типа задаётся экземпляр с обнулёнными полями. В этом случае можно использовать <code>default</code> или <code>new</code>.</li><li>Нельзя переименовывать параметры по умолчанию, так как это вызовет ошибку компиляции при передаче по имени параметра.</li><li>При вызове метода извне модуля параметр по умолчанию является потенциально опасным, так как его использует вызывающая сторона. И если не перекомпилировать вызывающий код при изменении исходного, это может спровоцировать ошибки.</li><li>Для параметров с ключевыми словами <code>ref</code> и <code>out</code> значения по умолчанию не задаются.</li></ul><p>Существуют дополнительные правила при вызове методов с необязательными или именованными параметрами:</p><ul><li>Аргументы могут идти в произвольном порядке, но именованные аргументы должны находиться в конце списка.</li><li>Передача по имени возможна для параметров, не имеющих значения по умолчанию, при этом компилятору должны быть переданы все аргументы, необходимые для компиляции.</li><li>В C# не могут отсутствовать аргументы. Если необходимо пропустить один параметр, стоит использовать именованные параметры.</li></ul><h3 id="атрибут-defaultparametervalue-и-необязательные-атрибуты" tabindex="-1"><a class="header-anchor" href="#атрибут-defaultparametervalue-и-необязательные-атрибуты"><span>Атрибут DefaultParameterValue и необязательные атрибуты</span></a></h3><p>Если компилятор встречает вызов метода, где не хватает параметров, он проверяет, содержат ли они специальные флаги в метаданных о том, являются ли они необязательными.</p><h2 id="неявно-типизированные-локальные-переменны" tabindex="-1"><a class="header-anchor" href="#неявно-типизированные-локальные-переменны"><span>Неявно типизированные локальные переменны</span></a></h2><p>В C# поддерживается возможность определения типа используемых в методе локальных переменных по типу используемого при их инициализации выражения. Эта возможность реализована с применением ключевого слова <code>var</code>. Неявно типизированной переменной нельзя присвоить <code>null</code>, так как компилятор не в состоянии определить, какой ссылочный или нуллабильный значимый тип разработчик хочет использовать.</p><p>Ключевое слово <code>var</code> позволяет сократить код, так как если разработчик захочет поменять тип переменной, ему не придётся переписывать его дважды (слева и справа от оператора присвоения).</p><p>Данное ключевое слово бывает также полезно при работе с коллекциями через циклы или при получении значения из метода. Однако в случае изменения возвращаемого типа или типа коллекции весь остальной код может перестать компилироваться.</p><h2 id="передача-параметров-в-метод-по-ссылке" tabindex="-1"><a class="header-anchor" href="#передача-параметров-в-метод-по-ссылке"><span>Передача параметров в метод по ссылке</span></a></h2><p>По умолчанию CLR предполагает, что все параметры методов передаются по значению. При передаче объекта ссылочного типа методу передаётся ссылка на объект (прим. Причём передаётся именно копия ссылки. Внутри метода можно изменить поле объекта, ссылка на который передана, или изменить саму ссылку, чтобы она указывала на другой объект). Если в метод передаётся значимый тип, то передаётся его копия. Следует знать тип объекта, передаваемого в метод, чтобы понимать, что с ним может там произойти.</p><p>CLR также позволяет передавать объект по ссылке, а не по значению, с помощью ключевых слов <code>ref</code> и <code>out</code>. Оба слова заставляют компилятор генерировать метаданные, описывающие параметр, как предаваемый по ссылке. Компилятор использует эти метаданные для генерации кода, передающего вместо самого параметра его адрес (прим. В случае ссылочного типа ссылка не копируется, а передаётся та же самая).</p><p>С точки зрения CLR эти ключевые слова отличаются только одним битом в метаданных, который указывает, какое конкретно слово было использовано. Однако их различает компилятор при выборе метода, используемого для инициализации объекта. Если параметр помечен ключевым словом <code>out</code>, вызывающий метод не инициализирует его, пока не вызван сам метод. В этом случае вызванный метод не может прочитать значение параметра и должен инициализировать его, прежде чем вернуть управление. Если же использовано ключевое слово <code>ref</code>, то вызванный метод может как читать, так и изменять его параметр.</p><p>При передаче по ссылке значимого типа передаётся адрес экземпляра этого типа в стеке. Отличие ключевых слов, как и описывалось ранее, состоит в том, что <code>out</code> не обязан принимать инициализированный параметр и может его инициализировать внутри вызванного метода, а <code>ref</code> должен принимать инициализированную переменную, которую сможет прочитать и изменить. Использование ключевого слова <code>out</code> со значимыми типами может повысить производительность, так как предотвращается копирование экземплярного полей значимого типа.</p><p>С точки зрения IL или CLR данные ключевые слова не различаются. Они лишь помогают компилятору гарантировать корректность кода. Например, нельзя передать в <code>ref</code> неинициализированное значение.</p><p>В C# можно создать перегрузки методов, которые отличаются наличием или отсутствием этих ключевых слов. Но вот перегрузки методов, отличающиеся этими ключевыми словами, создать нельзя, так как результатом из JIT-компиляции будет идентичный код метаданных.</p><p>Со значимыми типами использование данных ключевых слов даёт тот же результат, что и передача ссылочного типа по значению. Они позволяют методу управлять единственным экземпляром значимого типа. Вызывающий код выделяет память для этого экземпляра, а вызванный метод управляет выделенной памятью. В случае ссылочных типов вызывающий код выделяет память для указателя передаваемый объект, а вызванный код управляет этим указателем. В связи с этим использование ключевых слов со ссылочными типами полезно, лишь когда метод собирается вернуть ссылку на известный ему объект.</p><h2 id="передача-переменного-количества-аргументов" tabindex="-1"><a class="header-anchor" href="#передача-переменного-количества-аргументов"><span>Передача переменного количества аргументов</span></a></h2><p>метод, принимающий переменное числа параметров, объявляют с применением ключевого слова <code>params</code>. Метод с этим словом работает так, как будто ему передают массив, однако предоставляет более удобный синтаксис.</p><p>Обнаружив вызов подобного метода, компилятор сначала проверяет все методы с заданным именем, у которых ни один из параметров не помеченным атрибутом <code>ParamArray</code>. Найдя такой метод - компилятор генерирует вызывающий его код. Иначе ищутся методы с данным атрибутом и проверяется, могут ли они принять вызов. Если компилятор находит подходящий метод, то перед генерацией вызова метода генерируется код, создающий и заполняющий массив.</p><p>Данным ключевым словом может быть помечен только последний параметр.</p><p>Для написания метода, принимающего произвольное число параметров любого типа, стоит объявлять параметры типом <code>object</code>.</p><p>Вызов метода с переменным числом параметров снижает производительность, так как необходимо выделить под объекты массива память в куче, а потом эту память очистить (если в качестве аргумента не передаётся <code>null</code>). Для оптимизации данной работы стоит определить несколько перегрузок методов, которые принимают, например, один, два или три параметра, а через ключевое слово <code>params</code> описывать более редкие кейсы.</p><h2 id="типы-параметров-и-возвращаемых-значении" tabindex="-1"><a class="header-anchor" href="#типы-параметров-и-возвращаемых-значении"><span>Типы параметров и возвращаемых значений</span></a></h2><p>Объявляя тип параметров метода, нужно по возможности указывать &quot;минимальные&quot; типы, предпочитая интерфейсы базовым классам. Связано это с тем, что минимальный тип может принять большее число потенциальных типов аргумента.</p><p>В то же время, объявляя тип возвращаемого объекта, желательно выбирать самый сильный из доступных вариантов. Это сделано потому, что вызывающему методу лучше рассчитывать на конкретный набор членов типа.</p><p>Если же требуется сохранить возможность изменять возвращаемый тип, то следует выбирать более слабый тип возвращаемого значения, чтобы в будущем не появилось необходимости редактировать и вызывающий код. То есть стоит выбирать самый &quot;сильный&quot; из доступных самых &quot;слабых&quot; типов.</p><h2 id="константность" tabindex="-1"><a class="header-anchor" href="#константность"><span>Константность</span></a></h2><p>В некоторых языках имеется возможность объявления методов и параметров как константы, запрещая тем самым в экземплярном методы изменять поля объекта или объекты, передаваемые в метод. В CLR (и, соответственно, в C#) такой возможности нет.</p><p>Создавая реализацию типа, разработчик может просто избегать написания кода, меняющего объекты и параметры.</p>',36),t=[r];function p(o,n){return a(),l("div",null,t)}const h=e(d,[["render",p],["__file","ch09_Parameters.html.vue"]]),s=JSON.parse('{"path":"/ru/chapters/ch09_Parameters.html","title":"Параметры","lang":"ru-RU","frontmatter":{},"headers":[{"level":2,"title":"Необязательные и именованные параметры","slug":"необязательные-и-именованные-параметры","link":"#необязательные-и-именованные-параметры","children":[{"level":3,"title":"Правила использования параметров","slug":"правила-использования-параметров","link":"#правила-использования-параметров","children":[]},{"level":3,"title":"Атрибут DefaultParameterValue и необязательные атрибуты","slug":"атрибут-defaultparametervalue-и-необязательные-атрибуты","link":"#атрибут-defaultparametervalue-и-необязательные-атрибуты","children":[]}]},{"level":2,"title":"Неявно типизированные локальные переменны","slug":"неявно-типизированные-локальные-переменны","link":"#неявно-типизированные-локальные-переменны","children":[]},{"level":2,"title":"Передача параметров в метод по ссылке","slug":"передача-параметров-в-метод-по-ссылке","link":"#передача-параметров-в-метод-по-ссылке","children":[]},{"level":2,"title":"Передача переменного количества аргументов","slug":"передача-переменного-количества-аргументов","link":"#передача-переменного-количества-аргументов","children":[]},{"level":2,"title":"Типы параметров и возвращаемых значений","slug":"типы-параметров-и-возвращаемых-значении","link":"#типы-параметров-и-возвращаемых-значении","children":[]},{"level":2,"title":"Константность","slug":"константность","link":"#константность","children":[]}],"git":{"updatedTime":1712403629000},"filePathRelative":"ru/chapters/ch09_Parameters.md"}');export{h as comp,s as data};
